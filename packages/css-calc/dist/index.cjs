"use strict";var e=require("@csstools/css-tokenizer"),n=require("@csstools/css-parser-algorithms");function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const t=[];for(let o=0;o<e.inputs.length;o++){const i=e.inputs[o];if(n.isTokenNode(i)){t.push(i);continue}const r=solve(i);if(-1===r)return-1;t.push(r)}return e.operation(t)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.TokenType.Number||t[0]===e.TokenType.Dimension||t[0]===e.TokenType.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const o=t[0].value,i=t[1].value;if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const t=o[4].value*i[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Number){const t=o[4].value*i[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],i[3],{value:t}])}if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Percentage){const t=o[4].value*i[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],i[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Number){const t=o[4].value*i[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Dimension){const t=o[4].value*i[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+i[4].unit,o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:i[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const o=t[0].value,i=t[1].value;if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const t=o[4].value/i[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],i[3],{value:t,type:Number.isInteger(t)?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Number){const t=o[4].value/i[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],i[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Number){const t=o[4].value/i[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],i[3],{value:t,type:Number.isInteger(t)?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}const t=new Map([["cm",e=>e],["mm",e=>10*e],["q",e=>40*e],["in",e=>e/2.54],["pc",e=>e/2.54*6],["pt",e=>e/2.54*72],["px",e=>e/2.54*96]]),o=new Map([["deg",e=>e],["grad",e=>e/.9],["rad",e=>e/180*Math.PI],["turn",e=>e/360]]),i=new Map([["deg",e=>.9*e],["grad",e=>e],["rad",e=>.9*e/180*Math.PI],["turn",e=>.9*e/360]]),r=new Map([["hz",e=>e],["khz",e=>e/1e3]]),u=new Map([["cm",e=>2.54*e],["mm",e=>25.4*e],["q",e=>25.4*e*4],["in",e=>e],["pc",e=>6*e],["pt",e=>72*e],["px",e=>96*e]]),a=new Map([["hz",e=>1e3*e],["khz",e=>e]]),s=new Map([["cm",e=>e/10],["mm",e=>e],["q",e=>4*e],["in",e=>e/25.4],["pc",e=>e/25.4*6],["pt",e=>e/25.4*72],["px",e=>e/25.4*96]]),p=new Map([["ms",e=>e],["s",e=>e/1e3]]),c=new Map([["cm",e=>e/6*2.54],["mm",e=>e/6*25.4],["q",e=>e/6*25.4*4],["in",e=>e/6],["pc",e=>e],["pt",e=>e/6*72],["px",e=>e/6*96]]),l=new Map([["cm",e=>e/72*2.54],["mm",e=>e/72*25.4],["q",e=>e/72*25.4*4],["in",e=>e/72],["pc",e=>e/72*6],["pt",e=>e],["px",e=>e/72*96]]),T=new Map([["cm",e=>e/96*2.54],["mm",e=>e/96*25.4],["q",e=>e/96*25.4*4],["in",e=>e/96],["pc",e=>e/96*6],["pt",e=>e/96*72],["px",e=>e]]),N=new Map([["cm",e=>e/4/10],["mm",e=>e/4],["q",e=>e],["in",e=>e/4/25.4],["pc",e=>e/4/25.4*6],["pt",e=>e/4/25.4*72],["px",e=>e/4/25.4*96]]),y=new Map([["deg",e=>180*e/Math.PI],["grad",e=>180*e/Math.PI/.9],["rad",e=>e],["turn",e=>180*e/Math.PI/360]]),m=new Map([["ms",e=>1e3*e],["s",e=>e]]),k=new Map([["deg",e=>360*e],["grad",e=>360*e/.9],["rad",e=>360*e/180*Math.PI],["turn",e=>e]]),v=new Map([["cm",t],["mm",s],["q",N],["in",u],["pc",c],["pt",l],["px",T],["ms",p],["s",m],["deg",o],["grad",i],["rad",y],["turn",k],["hz",r],["khz",a]]);function convertUnit(n,t){if(n[0]!==e.TokenType.Dimension)return t;if(t[0]!==e.TokenType.Dimension)return t;const o=n[4].unit.toLowerCase(),i=t[4].unit.toLowerCase();if(o===i)return t;const r=v.get(i);if(!r)return t;const u=r.get(o);if(!u)return t;const a=u(t[4].value);return[e.TokenType.Dimension,a.toString()+n[4].unit,t[2],t[3],{value:a,unit:n[4].unit,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}]}function addition(t){if(2!==t.length)return-1;const o=t[0].value;let i=t[1].value;if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const t=o[4].value+i[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Percentage){const t=o[4].value+i[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],i[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Dimension&&(i=convertUnit(o,i),o[4].unit.toLowerCase()===i[4].unit.toLowerCase())){const t=o[4].value+i[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const o=t[0].value;let i=t[1].value;if(o[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const t=o[4].value-i[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Percentage){const t=o[4].value-i[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],i[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Dimension&&(i=convertUnit(o,i),o[4].unit.toLowerCase()===i[4].unit.toLowerCase())){const t=o[4].value-i[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],i[3],{value:t,type:o[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function solveMin(t,o){const i=o[0];if(!i||!n.isTokenNode(i))return-1;if(1!==new Set(o.map((e=>e.type))).size)return-1;const r=o[0].value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(o.map((e=>e.value[0]))).size)return-1;const u=o.map((e=>convertUnit(r,e.value)));if(1!==new Set(u.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=u.map((e=>e[4].value)),s=Math.min(...a),p=t.tokens();return r[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,s.toString()+r[4].unit,p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,s.toString()+"%",p[0][2],p[p.length-1][3],{value:s}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,s.toString(),p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveMax(t,o){const i=o[0];if(!i||!n.isTokenNode(i))return-1;if(1!==new Set(o.map((e=>e.type))).size)return-1;const r=o[0].value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(o.map((e=>e.value[0]))).size)return-1;const u=o.map((e=>convertUnit(r,e.value)));if(1!==new Set(u.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=u.map((e=>e[4].value)),s=Math.max(...a),p=t.tokens();return r[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,s.toString()+r[4].unit,p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,s.toString()+"%",p[0][2],p[p.length-1][3],{value:s}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,s.toString(),p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveClamp(t,o,i,r){if(!n.isTokenNode(o)||!n.isTokenNode(i)||!n.isTokenNode(r))return-1;const u=o.value,a=convertUnit(u,i.value),s=convertUnit(u,r.value);if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;if(u[0]!==a[0])return-1;if(u[0]!==s[0])return-1;if(u[0]===e.TokenType.Dimension){if(u[4].unit.toLowerCase()!==a[4].unit.toLowerCase())return-1;if(u[4].unit.toLowerCase()!==s[4].unit.toLowerCase())return-1}const p=Math.max(u[4].value,Math.min(a[4].value,s[4].value)),c=t.tokens();return u[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,p.toString()+u[4].unit,c[0][2],c[c.length-1][3],{value:p,type:Number.isInteger(p)?e.NumberType.Integer:e.NumberType.Number,unit:u[4].unit}])],operation:unary}:u[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,p.toString()+"%",c[0][2],c[c.length-1][3],{value:p}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,p.toString(),c[0][2],c[c.length-1][3],{value:p,type:Number.isInteger(p)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function resolveGlobalsAndConstants(t,o){for(let i=0;i<t.length;i++){const r=t[i];if(!n.isTokenNode(r))continue;const u=r.value;if(u[0]!==e.TokenType.Ident)continue;const a=u[4].value.toLowerCase();switch(a){case"e":t.splice(i,1,new n.TokenNode([e.TokenType.Number,Math.E.toString(),u[2],u[3],{value:Math.E,type:e.NumberType.Number}]));break;case"pi":t.splice(i,1,new n.TokenNode([e.TokenType.Number,Math.PI.toString(),u[2],u[3],{value:Math.PI,type:e.NumberType.Number}]));break;case"infinity":t.splice(i,1,new n.TokenNode([e.TokenType.Number,"infinity",u[2],u[3],{value:1/0,type:e.NumberType.Number}]));break;case"-infinity":t.splice(i,1,new n.TokenNode([e.TokenType.Number,"-infinity",u[2],u[3],{value:-1/0,type:e.NumberType.Number}]));break;case"nan":t.splice(i,1,new n.TokenNode([e.TokenType.Number,"NaN",u[2],u[3],{value:Number.NaN,type:e.NumberType.Number}]));break;default:if(o.has(a)){const e=o.get(a);t.splice(i,1,new n.TokenNode(e))}}}return t}function solveRound(t,o,i,r){const u=i.value;if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;const a=convertUnit(u,r.value);if(u[0]!==a[0])return-1;if(u[0]===e.TokenType.Dimension&&u[4].unit!==a[4].unit)return-1;let s;if(0===a[4].value)s=Number.NaN;else if(Number.isFinite(u[4].value)||Number.isFinite(a[4].value))if(!Number.isFinite(u[4].value)&&Number.isFinite(a[4].value))s=u[4].value;else if(Number.isFinite(u[4].value)&&!Number.isFinite(a[4].value))switch(o){case"down":s=u[4].value<0?-1/0:Object.is(-0,0*u[4].value)?-0:0;break;case"up":s=u[4].value>0?1/0:Object.is(0,0*u[4].value)?0:-0;break;default:s=Object.is(0,0*u[4].value)?0:-0}else switch(o){case"down":s=Math.floor(u[4].value/a[4].value)*a[4].value;break;case"up":s=Math.ceil(u[4].value/a[4].value)*a[4].value;break;case"to-zero":s=Math.trunc(u[4].value/a[4].value)*a[4].value;break;default:{let e=Math.floor(u[4].value/a[4].value)*a[4].value,n=Math.ceil(u[4].value/a[4].value)*a[4].value;if(e>n){const t=e;e=n,n=t}const t=Math.abs(u[4].value-e),o=Math.abs(u[4].value-n);t===o&&(s=n),s=t<o?e:n;break}}else s=Number.NaN;const p=t.tokens();return u[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,s.toString()+u[4].unit,p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number,unit:u[4].unit}])],operation:unary}:u[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,s.toString()+"%",p[0][2],p[p.length-1][3],{value:s}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,s.toString(),p[0][2],p[p.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveMod(t,o,i){const r=o.value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Percentage)return-1;const u=convertUnit(r,i.value);if(r[0]!==u[0])return-1;if(r[0]===e.TokenType.Dimension&&r[4].unit!==u[4].unit)return-1;const a=(r[4].value%u[4].value+u[4].value)%u[4].value,s=t.tokens();return r[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,a.toString()+r[4].unit,s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,a.toString()+"%",s[0][2],s[s.length-1][3],{value:a}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,a.toString(),s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveRem(t,o,i){const r=o.value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Percentage)return-1;const u=convertUnit(r,i.value);if(r[0]!==u[0])return-1;if(r[0]===e.TokenType.Dimension&&r[4].unit!==u[4].unit)return-1;const a=r[4].value%u[4].value,s=t.tokens();return r[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,a.toString()+r[4].unit,s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,a.toString()+"%",s[0][2],s[s.length-1][3],{value:a}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,a.toString(),s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function calc(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o);if(1===i.length&&n.isTokenNode(i[0]))return{inputs:[i[0]],operation:unary};let r=0;for(;r<i.length;){const t=i[r];if(n.isSimpleBlockNode(t)&&t.startToken[0]===e.TokenType.OpenParen){const e=calc(t,o);if(-1===e)return-1;i.splice(r,1,e)}else if(n.isFunctionNode(t))switch(t.getName().toLowerCase()){case"calc":{const e=calc(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"clamp":{const e=clamp(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"min":{const e=min(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"max":{const e=max(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"round":{const e=round(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"mod":{const e=mod(t,o);if(-1===e)return-1;i.splice(r,1,e);break}case"rem":{const e=rem(t,o);if(-1===e)return-1;i.splice(r,1,e);break}default:return-1}else r++}if(r=0,1===i.length&&isCalculation(i[0]))return i[0];for(;r<i.length;){const t=i[r];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){r++;continue}const o=i[r+1];if(!o||!n.isTokenNode(o)){r++;continue}const u=o.value;if(u[0]!==e.TokenType.Delim||"*"!==u[4].value&&"/"!==u[4].value){r++;continue}const a=i[r+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"*"!==u[4].value?"/"!==u[4].value?r++:i.splice(r,3,{inputs:[t,a],operation:division}):i.splice(r,3,{inputs:[t,a],operation:multiplication})}if(r=0,1===i.length&&isCalculation(i[0]))return i[0];for(;r<i.length;){const t=i[r];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){r++;continue}const o=i[r+1];if(!o||!n.isTokenNode(o)){r++;continue}const u=o.value;if(u[0]!==e.TokenType.Delim||"+"!==u[4].value&&"-"!==u[4].value){r++;continue}const a=i[r+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"+"!==u[4].value?"-"!==u[4].value?r++:i.splice(r,3,{inputs:[t,a],operation:subtraction}):i.splice(r,3,{inputs:[t,a],operation:addition})}return 1===i.length&&isCalculation(i[0])?i[0]:-1}function clamp(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o),r=[],u=[],a=[];{let t=r;for(let o=0;o<i.length;o++){const s=i[o];if(n.isTokenNode(s)&&s.value[0]===e.TokenType.Comma){if(t===a)return-1;if(t===u){t=a;continue}if(t===r){t=u;continue}return-1}t.push(s)}}const s=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),o));if(-1===s)return-1;const p=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),o));if(-1===p)return-1;const c=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],a),o));return-1===c?-1:solveClamp(t,s,p,c)}function max(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o),r=[];{const t=[];let u=[];for(let o=0;o<i.length;o++){const r=i[o];n.isTokenNode(r)&&r.value[0]===e.TokenType.Comma?(t.push(u),u=[]):u.push(r)}t.push(u);for(let i=0;i<t.length;i++){if(0===t[i].length)return-1;const u=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],t[i]),o));if(-1===u)return-1;r.push(u)}}return solveMax(t,r)}function min(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o),r=[];{const t=[];let u=[];for(let o=0;o<i.length;o++){const r=i[o];n.isTokenNode(r)&&r.value[0]===e.TokenType.Comma?(t.push(u),u=[]):u.push(r)}t.push(u);for(let i=0;i<t.length;i++){if(0===t[i].length)return-1;const u=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],t[i]),o));if(-1===u)return-1;r.push(u)}}return solveMin(t,r)}const f=new Set(["nearest","up","down","to-zero"]);function round(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o);let r="";const u=[],a=[];{let t=u;for(let o=0;o<i.length;o++){const s=i[o];if(!r&&0===u.length&&0===a.length&&n.isTokenNode(s)&&s.value[0]===e.TokenType.Ident){const e=s.value;if(f.has(e[4].value.toLowerCase())){r=e[4].value.toLowerCase();continue}}if(n.isTokenNode(s)&&s.value[0]===e.TokenType.Comma){if(t===a)return-1;if(t===u&&r&&0===u.length)continue;if(t===u){t=a;continue}return-1}t.push(s)}}const s=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),o));if(-1===s)return-1;const p=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],a),o));return-1===p?-1:(r||(r="nearest"),solveRound(t,r,s,p))}function mod(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o),r=[],u=[];{let t=r;for(let o=0;o<i.length;o++){const a=i[o];if(n.isTokenNode(a)&&a.value[0]===e.TokenType.Comma){if(t===u)return-1;if(t===r){t=u;continue}return-1}t.push(a)}}const a=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),o));if(-1===a)return-1;const s=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),o));return-1===s?-1:solveMod(t,a,s)}function rem(t,o){const i=resolveGlobalsAndConstants([...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],o),r=[],u=[];{let t=r;for(let o=0;o<i.length;o++){const a=i[o];if(n.isTokenNode(a)&&a.value[0]===e.TokenType.Comma){if(t===u)return-1;if(t===r){t=u;continue}return-1}t.push(a)}}const a=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),o));if(-1===a)return-1;const s=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),o));return-1===s?-1:solveRem(t,a,s)}function tokenizeGlobals(n){const t=new Map;if(!n)return t;for(const[o,i]of n)if(e.isToken(i))t.set(o,i);else if("string"!=typeof i);else{const n=e.tokenizer({css:i}),r=n.nextToken();if(n.nextToken(),!n.endOfFile())continue;if(r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Percentage)continue;t.set(o,r)}return t}function patchNaN(t){if(-1===t)return-1;if(n.isFunctionNode(t))return t;const o=t.value;return o[0]!==e.TokenType.Number&&o[0]!==e.TokenType.Percentage&&o[0]!==e.TokenType.Dimension?t:Number.isNaN(o[4].value)?o[0]===e.TokenType.Number?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",o[2],o[3],{value:"NaN"}])]):o[0]===e.TokenType.Dimension?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",o[2],o[3],{value:"NaN"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",o[2],o[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Dimension,"1"+o[4].unit,o[2],o[3],{value:1,type:e.NumberType.Integer,unit:o[4].unit}])]):o[0]===e.TokenType.Percentage?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",o[2],o[3],{value:"NaN"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",o[2],o[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Percentage,"1%",o[2],o[3],{value:1}])]):-1:t}function patchInfinity(t){if(-1===t)return-1;if(n.isFunctionNode(t))return t;const o=t.value;if(o[0]!==e.TokenType.Number&&o[0]!==e.TokenType.Percentage&&o[0]!==e.TokenType.Dimension)return t;if(Number.isFinite(o[4].value))return t;let i="";return Number.NEGATIVE_INFINITY===o[4].value&&(i="-"),o[0]===e.TokenType.Number?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",o[2],o[3],{value:i+"infinity"}])]):o[0]===e.TokenType.Dimension?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",o[2],o[3],{value:i+"infinity"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",o[2],o[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Dimension,"1"+o[4].unit,o[2],o[3],{value:1,type:e.NumberType.Integer,unit:o[4].unit}])]):o[0]===e.TokenType.Percentage?new n.FunctionNode([e.TokenType.Function,"calc(",o[2],o[3],{value:"calc"}],[e.TokenType.CloseParen,")",o[2],o[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",o[2],o[3],{value:i+"infinity"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",o[2],o[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",o[2],o[3],void 0]]),new n.TokenNode([e.TokenType.Percentage,"1%",o[2],o[3],{value:1}])]):-1}function patchMinusZero(t){if(-1===t)return-1;if(n.isFunctionNode(t))return t;const o=t.value;return o[0]!==e.TokenType.Number&&o[0]!==e.TokenType.Percentage&&o[0]!==e.TokenType.Dimension?t:Object.is(-0,o[4].value)?("-0"===o[1]||(o[1]="-0"),t):t}exports.convert=function convert(t,o){const i=tokenizeGlobals(o),r=e.tokenizer({css:t}),u=[];for(;!r.endOfFile();)u.push(r.nextToken());u.push(r.nextToken());const a=n.parseCommaSeparatedListOfComponentValues(u,{});for(let e=0;e<a.length;e++){const t=a[e];for(let e=0;e<t.length;e++){const o=t[e];if(n.isFunctionNode(o))if("calc"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(calc(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("clamp"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(clamp(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("min"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(min(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("max"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(max(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("round"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(round(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("mod"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(mod(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}else if("rem"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(rem(o,i)))));if(-1!==n){t.splice(e,1,n);continue}}(n.isSimpleBlockNode(o)||n.isFunctionNode(o))&&o.walk(((e,t)=>{if("number"!=typeof t)return;const o=e.node;if(n.isFunctionNode(o))if("calc"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(calc(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("clamp"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(clamp(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("min"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(min(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("max"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(max(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("round"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(round(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("mod"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(mod(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("rem"===o.getName().toLowerCase()){const n=patchMinusZero(patchInfinity(patchNaN(solve(rem(o,i)))));if(-1!==n)return void e.parent.value.splice(t,1,n)}}))}}return a.map((n=>n.map((n=>e.stringify(...n.tokens()))).join(""))).join(",")};
