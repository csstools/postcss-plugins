"use strict";var e=require("@csstools/css-tokenizer"),n=require("@csstools/css-parser-algorithms");function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const o=[];for(let t=0;t<e.inputs.length;t++){const i=e.inputs[t];if(n.isTokenNode(i)){o.push(i);continue}const u=solve(i);if(-1===u)return-1;o.push(u)}return e.operation(o)}function unary(n){if(1!==n.length)return-1;const o=n[0].value;return o[0]===e.TokenType.Number||o[0]===e.TokenType.Dimension||o[0]===e.TokenType.Percentage?n[0]:-1}function multiplication(o){if(2!==o.length)return-1;const t=o[0].value,i=o[1].value;if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const o=t[4].value*i[4].value;return new n.TokenNode([e.TokenType.Number,o.toString(),t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(t[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Number){const o=t[4].value*i[4].value;return new n.TokenNode([e.TokenType.Percentage,o.toString()+"%",t[2],i[3],{value:o}])}if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Percentage){const o=t[4].value*i[4].value;return new n.TokenNode([e.TokenType.Percentage,o.toString()+"%",t[2],i[3],{value:o}])}if(t[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Number){const o=t[4].value*i[4].value;return new n.TokenNode([e.TokenType.Dimension,o.toString()+t[4].unit,t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:t[4].unit}])}if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Dimension){const o=t[4].value*i[4].value;return new n.TokenNode([e.TokenType.Dimension,o.toString()+i[4].unit,t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:i[4].unit}])}return-1}function division(o){if(2!==o.length)return-1;const t=o[0].value,i=o[1].value;if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const o=t[4].value/i[4].value;return new n.TokenNode([e.TokenType.Number,o.toString(),t[2],i[3],{value:o,type:Number.isInteger(o)?e.NumberType.Integer:e.NumberType.Number}])}if(t[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Number){const o=t[4].value/i[4].value;return new n.TokenNode([e.TokenType.Percentage,o.toString()+"%",t[2],i[3],{value:o}])}if(t[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Number){const o=t[4].value/i[4].value;return new n.TokenNode([e.TokenType.Dimension,o.toString()+t[4].unit,t[2],i[3],{value:o,type:Number.isInteger(o)?e.NumberType.Integer:e.NumberType.Number,unit:t[4].unit}])}return-1}const o={cm:"px",in:"px",mm:"px",pc:"px",pt:"px",px:"px",q:"px",deg:"deg",grad:"deg",rad:"deg",turn:"deg",ms:"s",s:"s",hz:"hz",khz:"khz"},t=new Map([["cm",e=>e],["mm",e=>10*e],["q",e=>40*e],["in",e=>e/2.54],["pc",e=>e/2.54*6],["pt",e=>e/2.54*72],["px",e=>e/2.54*96]]),i=new Map([["deg",e=>e],["grad",e=>e/.9],["rad",e=>e/180*Math.PI],["turn",e=>e/360]]),u=new Map([["deg",e=>.9*e],["grad",e=>e],["rad",e=>.9*e/180*Math.PI],["turn",e=>.9*e/360]]),r=new Map([["hz",e=>e],["khz",e=>e/1e3]]),a=new Map([["cm",e=>2.54*e],["mm",e=>25.4*e],["q",e=>25.4*e*4],["in",e=>e],["pc",e=>6*e],["pt",e=>72*e],["px",e=>96*e]]),s=new Map([["hz",e=>1e3*e],["khz",e=>e]]),l=new Map([["cm",e=>e/10],["mm",e=>e],["q",e=>4*e],["in",e=>e/25.4],["pc",e=>e/25.4*6],["pt",e=>e/25.4*72],["px",e=>e/25.4*96]]),c=new Map([["ms",e=>e],["s",e=>e/1e3]]),T=new Map([["cm",e=>e/6*2.54],["mm",e=>e/6*25.4],["q",e=>e/6*25.4*4],["in",e=>e/6],["pc",e=>e],["pt",e=>e/6*72],["px",e=>e/6*96]]),p=new Map([["cm",e=>e/72*2.54],["mm",e=>e/72*25.4],["q",e=>e/72*25.4*4],["in",e=>e/72],["pc",e=>e/72*6],["pt",e=>e],["px",e=>e/72*96]]),v=new Map([["cm",e=>e/96*2.54],["mm",e=>e/96*25.4],["q",e=>e/96*25.4*4],["in",e=>e/96],["pc",e=>e/96*6],["pt",e=>e/96*72],["px",e=>e]]),m=new Map([["cm",e=>e/4/10],["mm",e=>e/4],["q",e=>e],["in",e=>e/4/25.4],["pc",e=>e/4/25.4*6],["pt",e=>e/4/25.4*72],["px",e=>e/4/25.4*96]]),N=new Map([["deg",e=>180*e/Math.PI],["grad",e=>180*e/Math.PI/.9],["rad",e=>e],["turn",e=>180*e/Math.PI/360]]),y=new Map([["ms",e=>1e3*e],["s",e=>e]]),k=new Map([["deg",e=>360*e],["grad",e=>360*e/.9],["rad",e=>360*e/180*Math.PI],["turn",e=>e]]),d=new Map([["cm",t],["mm",l],["q",m],["in",a],["pc",T],["pt",p],["px",v],["ms",c],["s",y],["deg",i],["grad",u],["rad",N],["turn",k],["hz",r],["khz",s]]);function convertUnit(n,o){if(n[0]!==e.TokenType.Dimension)return o;if(o[0]!==e.TokenType.Dimension)return o;const t=n[4].unit.toLowerCase(),i=o[4].unit.toLowerCase();if(t===i)return o;const u=d.get(i);if(!u)return o;const r=u.get(t);if(!r)return o;const a=r(o[4].value);return[e.TokenType.Dimension,a.toString()+n[4].unit,o[2],o[3],{value:a,unit:n[4].unit,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}]}function toCanonicalUnit(n){if(n[0]!==e.TokenType.Dimension)return n;const t=n[4].unit.toLowerCase(),i=o[t];if(t===i)return n;const u=d.get(t);if(!u)return n;const r=u.get(i);if(!r)return n;const a=r(n[4].value);return[e.TokenType.Dimension,a.toString()+i,n[2],n[3],{value:a,unit:i,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}]}function addition(o){if(2!==o.length)return-1;const t=o[0].value;let i=o[1].value;if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const o=t[4].value+i[4].value;return new n.TokenNode([e.TokenType.Number,o.toString(),t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(t[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Percentage){const o=t[4].value+i[4].value;return new n.TokenNode([e.TokenType.Percentage,o.toString()+"%",t[2],i[3],{value:o}])}if(t[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Dimension&&(i=convertUnit(t,i),t[4].unit.toLowerCase()===i[4].unit.toLowerCase())){const o=t[4].value+i[4].value;return new n.TokenNode([e.TokenType.Dimension,o.toString()+t[4].unit,t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:t[4].unit}])}return-1}function subtraction(o){if(2!==o.length)return-1;const t=o[0].value;let i=o[1].value;if(t[0]===e.TokenType.Number&&i[0]===e.TokenType.Number){const o=t[4].value-i[4].value;return new n.TokenNode([e.TokenType.Number,o.toString(),t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(t[0]===e.TokenType.Percentage&&i[0]===e.TokenType.Percentage){const o=t[4].value-i[4].value;return new n.TokenNode([e.TokenType.Percentage,o.toString()+"%",t[2],i[3],{value:o}])}if(t[0]===e.TokenType.Dimension&&i[0]===e.TokenType.Dimension&&(i=convertUnit(t,i),t[4].unit.toLowerCase()===i[4].unit.toLowerCase())){const o=t[4].value-i[4].value;return new n.TokenNode([e.TokenType.Dimension,o.toString()+t[4].unit,t[2],i[3],{value:o,type:t[4].type===e.NumberType.Integer&&i[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:t[4].unit}])}return-1}function resultToCalculation(o,t,i){const u=o.tokens();return t[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,i.toString()+t[4].unit,u[0][2],u[u.length-1][3],{value:i,type:Number.isInteger(i)?e.NumberType.Integer:e.NumberType.Number,unit:t[4].unit}])],operation:unary}:t[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,i.toString()+"%",u[0][2],u[u.length-1][3],{value:i}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,i.toString(),u[0][2],u[u.length-1][3],{value:i,type:Number.isInteger(i)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveMin(o,t){const i=t[0];if(!i||!n.isTokenNode(i))return-1;if(1!==new Set(t.map((e=>e.type))).size)return-1;const u=t[0].value;if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(t.map((e=>e.value[0]))).size)return-1;const r=t.map((e=>convertUnit(u,e.value)));if(1!==new Set(r.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=r.map((e=>e[4].value)),s=Math.min(...a);return resultToCalculation(o,u,s)}function solveMax(o,t){const i=t[0];if(!i||!n.isTokenNode(i))return-1;if(1!==new Set(t.map((e=>e.type))).size)return-1;const u=t[0].value;if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(t.map((e=>e.value[0]))).size)return-1;const r=t.map((e=>convertUnit(u,e.value)));if(1!==new Set(r.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=r.map((e=>e[4].value)),s=Math.max(...a);return resultToCalculation(o,u,s)}function solveClamp(o,t,i,u){if(!n.isTokenNode(t)||!n.isTokenNode(i)||!n.isTokenNode(u))return-1;const r=t.value,a=convertUnit(r,i.value),s=convertUnit(r,u.value);if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number&&r[0]!==e.TokenType.Percentage)return-1;if(r[0]!==a[0])return-1;if(r[0]!==s[0])return-1;if(r[0]===e.TokenType.Dimension){if(r[4].unit.toLowerCase()!==a[4].unit.toLowerCase())return-1;if(r[4].unit.toLowerCase()!==s[4].unit.toLowerCase())return-1}return resultToCalculation(o,r,Math.max(r[4].value,Math.min(a[4].value,s[4].value)))}function resolveGlobalsAndConstants(o,t){for(let i=0;i<o.length;i++){const u=o[i];if(!n.isTokenNode(u))continue;const r=u.value;if(r[0]!==e.TokenType.Ident)continue;const a=r[4].value.toLowerCase();switch(a){case"e":o.splice(i,1,new n.TokenNode([e.TokenType.Number,Math.E.toString(),r[2],r[3],{value:Math.E,type:e.NumberType.Number}]));break;case"pi":o.splice(i,1,new n.TokenNode([e.TokenType.Number,Math.PI.toString(),r[2],r[3],{value:Math.PI,type:e.NumberType.Number}]));break;case"infinity":o.splice(i,1,new n.TokenNode([e.TokenType.Number,"infinity",r[2],r[3],{value:1/0,type:e.NumberType.Number}]));break;case"-infinity":o.splice(i,1,new n.TokenNode([e.TokenType.Number,"-infinity",r[2],r[3],{value:-1/0,type:e.NumberType.Number}]));break;case"nan":o.splice(i,1,new n.TokenNode([e.TokenType.Number,"NaN",r[2],r[3],{value:Number.NaN,type:e.NumberType.Number}]));break;default:if(t.has(a)){const e=t.get(a);o.splice(i,1,new n.TokenNode(e))}}}return o}function solveRound(n,o,t,i){const u=t.value;if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;const r=convertUnit(u,i.value);if(u[0]!==r[0])return-1;if(u[0]===e.TokenType.Dimension&&u[4].unit!==r[4].unit)return-1;let a;if(0===r[4].value)a=Number.NaN;else if(Number.isFinite(u[4].value)||Number.isFinite(r[4].value))if(!Number.isFinite(u[4].value)&&Number.isFinite(r[4].value))a=u[4].value;else if(Number.isFinite(u[4].value)&&!Number.isFinite(r[4].value))switch(o){case"down":a=u[4].value<0?-1/0:Object.is(-0,0*u[4].value)?-0:0;break;case"up":a=u[4].value>0?1/0:Object.is(0,0*u[4].value)?0:-0;break;default:a=Object.is(0,0*u[4].value)?0:-0}else if(Number.isFinite(r[4].value))switch(o){case"down":a=Math.floor(u[4].value/r[4].value)*r[4].value;break;case"up":a=Math.ceil(u[4].value/r[4].value)*r[4].value;break;case"to-zero":a=Math.trunc(u[4].value/r[4].value)*r[4].value;break;default:{let e=Math.floor(u[4].value/r[4].value)*r[4].value,n=Math.ceil(u[4].value/r[4].value)*r[4].value;if(e>n){const o=e;e=n,n=o}const o=Math.abs(u[4].value-e),t=Math.abs(u[4].value-n);o===t&&(a=n),a=o<t?e:n;break}}else a=u[4].value;else a=Number.NaN;return resultToCalculation(n,u,a)}function solveMod(n,o,t){const i=o.value;if(i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Percentage)return-1;const u=convertUnit(i,t.value);if(i[0]!==u[0])return-1;if(i[0]===e.TokenType.Dimension&&i[4].unit!==u[4].unit)return-1;let r;return r=0===u[4].value?Number.NaN:Number.isFinite(i[4].value)&&(Number.isFinite(u[4].value)||(u[4].value!==Number.POSITIVE_INFINITY||i[4].value!==Number.NEGATIVE_INFINITY&&!Object.is(0*i[4].value,-0))&&(u[4].value!==Number.NEGATIVE_INFINITY||i[4].value!==Number.POSITIVE_INFINITY&&!Object.is(0*i[4].value,0)))?Number.isFinite(u[4].value)?(i[4].value%u[4].value+u[4].value)%u[4].value:i[4].value:Number.NaN,resultToCalculation(n,i,r)}function solveRem(n,o,t){const i=o.value;if(i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Percentage)return-1;const u=convertUnit(i,t.value);if(i[0]!==u[0])return-1;if(i[0]===e.TokenType.Dimension&&i[4].unit!==u[4].unit)return-1;let r;return r=0===u[4].value?Number.NaN:Number.isFinite(i[4].value)?Number.isFinite(u[4].value)?i[4].value%u[4].value:i[4].value:Number.NaN,resultToCalculation(n,i,r)}function solveAbs(n,o){const t=o.value;if(t[0]!==e.TokenType.Dimension&&t[0]!==e.TokenType.Number)return-1;return resultToCalculation(n,t,Math.abs(t[4].value))}function solveSign(o,t){const i=t.value;if(i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Number)return-1;const u=Math.sign(i[4].value),r=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Number,u.toString(),r[0][2],r[r.length-1][3],{value:u,type:Number.isInteger(u)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveSin(o,t){const r=t.value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number)return-1;if(r[0]===e.TokenType.Dimension)switch(r[4].unit.toLowerCase()){case"rad":break;case"deg":r[4].value=i.get("rad")(r[4].value);break;case"grad":r[4].value=u.get("rad")(r[4].value);break;case"turn":r[4].value=k.get("rad")(r[4].value);break;default:return-1}const a=Math.sin(r[4].value),s=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Number,a.toString(),s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveCos(o,t){const r=t.value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number)return-1;if(r[0]===e.TokenType.Dimension)switch(r[4].unit.toLowerCase()){case"rad":break;case"deg":r[4].value=i.get("rad")(r[4].value);break;case"grad":r[4].value=u.get("rad")(r[4].value);break;case"turn":r[4].value=k.get("rad")(r[4].value);break;default:return-1}const a=Math.cos(r[4].value),s=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Number,a.toString(),s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveTan(o,t){const r=t.value;if(r[0]!==e.TokenType.Dimension&&r[0]!==e.TokenType.Number)return-1;const a=r[4].value;let s=0;if(r[0]===e.TokenType.Dimension)switch(r[4].unit.toLowerCase()){case"rad":s=N.get("deg")(a);break;case"deg":s=a,r[4].value=i.get("rad")(a);break;case"grad":s=u.get("deg")(a),r[4].value=u.get("rad")(a);break;case"turn":s=k.get("deg")(a),r[4].value=k.get("rad")(a);break;default:return-1}const l=s/90;let c;c=s%90==0&&l%2!=0?l>0?1/0:-1/0:Math.tan(r[4].value);const T=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Number,c.toString(),T[0][2],T[T.length-1][3],{value:c,type:Number.isInteger(c)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveASin(o,t){const i=t.value;if(i[0]!==e.TokenType.Number)return-1;const u=Math.asin(i[4].value),r=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Dimension,u.toString()+"rad",r[0][2],r[r.length-1][3],{value:u,type:Number.isInteger(u)?e.NumberType.Integer:e.NumberType.Number,unit:"rad"}])],operation:unary}}function solveACos(o,t){const i=t.value;if(i[0]!==e.TokenType.Number)return-1;const u=Math.acos(i[4].value),r=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Dimension,u.toString()+"rad",r[0][2],r[r.length-1][3],{value:u,type:Number.isInteger(u)?e.NumberType.Integer:e.NumberType.Number,unit:"rad"}])],operation:unary}}function solveATan(o,t){const i=t.value;if(i[0]!==e.TokenType.Number)return-1;const u=Math.atan(i[4].value),r=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Dimension,u.toString()+"rad",r[0][2],r[r.length-1][3],{value:u,type:Number.isInteger(u)?e.NumberType.Integer:e.NumberType.Number,unit:"rad"}])],operation:unary}}function solveATan2(o,t,i){const u=t.value;if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number)return-1;const r=convertUnit(u,i.value);if(u[0]!==r[0])return-1;if(u[0]===e.TokenType.Dimension&&u[4].unit!==r[4].unit)return-1;const a=Math.atan2(u[4].value,r[4].value),s=o.tokens();return{inputs:[new n.TokenNode([e.TokenType.Dimension,a.toString()+"rad",s[0][2],s[s.length-1][3],{value:a,type:Number.isInteger(a)?e.NumberType.Integer:e.NumberType.Number,unit:"rad"}])],operation:unary}}const f=new Map([["abs",abs],["acos",acos],["asin",asin],["atan",atan],["atan2",atan2],["calc",calc$1],["clamp",clamp],["cos",cos],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign],["sin",sin],["tan",tan]]);function calc$1(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t);if(1===i.length&&n.isTokenNode(i[0]))return{inputs:[i[0]],operation:unary};let u=0;for(;u<i.length;){const o=i[u];if(n.isSimpleBlockNode(o)&&o.startToken[0]===e.TokenType.OpenParen){const e=calc$1(o,t);if(-1===e)return-1;i.splice(u,1,e)}else if(n.isFunctionNode(o)){const e=f.get(o.getName().toLowerCase());if(!e)return-1;{const n=e(o,t);if(-1===n)return-1;i.splice(u,1,n)}}else u++}if(u=0,1===i.length&&isCalculation(i[0]))return i[0];for(;u<i.length;){const o=i[u];if(!o||!n.isTokenNode(o)&&!isCalculation(o)){u++;continue}const t=i[u+1];if(!t||!n.isTokenNode(t)){u++;continue}const r=t.value;if(r[0]!==e.TokenType.Delim||"*"!==r[4].value&&"/"!==r[4].value){u++;continue}const a=i[u+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"*"!==r[4].value?"/"!==r[4].value?u++:i.splice(u,3,{inputs:[o,a],operation:division}):i.splice(u,3,{inputs:[o,a],operation:multiplication})}if(u=0,1===i.length&&isCalculation(i[0]))return i[0];for(;u<i.length;){const o=i[u];if(!o||!n.isTokenNode(o)&&!isCalculation(o)){u++;continue}const t=i[u+1];if(!t||!n.isTokenNode(t)){u++;continue}const r=t.value;if(r[0]!==e.TokenType.Delim||"+"!==r[4].value&&"-"!==r[4].value){u++;continue}const a=i[u+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"+"!==r[4].value?"-"!==r[4].value?u++:i.splice(u,3,{inputs:[o,a],operation:subtraction}):i.splice(u,3,{inputs:[o,a],operation:addition})}return 1===i.length&&isCalculation(i[0])?i[0]:-1}function clamp(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[],r=[],a=[];{let o=u;for(let t=0;t<i.length;t++){const s=i[t];if(n.isTokenNode(s)&&s.value[0]===e.TokenType.Comma){if(o===a)return-1;if(o===r){o=a;continue}if(o===u){o=r;continue}return-1}o.push(s)}}const s=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),t));if(-1===s)return-1;const l=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),t));if(-1===l)return-1;const c=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],a),t));return-1===c?-1:solveClamp(o,s,l,c)}function max(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[];{const o=[];let r=[];for(let t=0;t<i.length;t++){const u=i[t];n.isTokenNode(u)&&u.value[0]===e.TokenType.Comma?(o.push(r),r=[]):r.push(u)}o.push(r);for(let i=0;i<o.length;i++){if(0===o[i].length)return-1;const r=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],o[i]),t));if(-1===r)return-1;u.push(r)}}return solveMax(o,u)}function min(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[];{const o=[];let r=[];for(let t=0;t<i.length;t++){const u=i[t];n.isTokenNode(u)&&u.value[0]===e.TokenType.Comma?(o.push(r),r=[]):r.push(u)}o.push(r);for(let i=0;i<o.length;i++){if(0===o[i].length)return-1;const r=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],o[i]),t));if(-1===r)return-1;u.push(r)}}return solveMin(o,u)}const b=new Set(["nearest","up","down","to-zero"]);function round(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t);let u="";const r=[],a=[];{let o=r;for(let t=0;t<i.length;t++){const s=i[t];if(!u&&0===r.length&&0===a.length&&n.isTokenNode(s)&&s.value[0]===e.TokenType.Ident){const e=s.value;if(b.has(e[4].value.toLowerCase())){u=e[4].value.toLowerCase();continue}}if(n.isTokenNode(s)&&s.value[0]===e.TokenType.Comma){if(o===a)return-1;if(o===r&&u&&0===r.length)continue;if(o===r){o=a;continue}return-1}o.push(s)}}const s=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),t));if(-1===s)return-1;const l=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],a),t));return-1===l?-1:(u||(u="nearest"),solveRound(o,u,s,l))}function mod(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[],r=[];{let o=u;for(let t=0;t<i.length;t++){const a=i[t];if(n.isTokenNode(a)&&a.value[0]===e.TokenType.Comma){if(o===r)return-1;if(o===u){o=r;continue}return-1}o.push(a)}}const a=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),t));if(-1===a)return-1;const s=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),t));return-1===s?-1:solveMod(o,a,s)}function rem(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[],r=[];{let o=u;for(let t=0;t<i.length;t++){const a=i[t];if(n.isTokenNode(a)&&a.value[0]===e.TokenType.Comma){if(o===r)return-1;if(o===u){o=r;continue}return-1}o.push(a)}}const a=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),t));if(-1===a)return-1;const s=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),t));return-1===s?-1:solveRem(o,a,s)}function abs(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveAbs(o,u)}function sign(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveSign(o,u)}function sin(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveSin(o,u)}function cos(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveCos(o,u)}function tan(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveTan(o,u)}function asin(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveASin(o,u)}function acos(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveACos(o,u)}function atan(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveATan(o,u)}function atan2(o,t){const i=resolveGlobalsAndConstants([...o.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],t),u=[],r=[];{let o=u;for(let t=0;t<i.length;t++){const a=i[t];if(n.isTokenNode(a)&&a.value[0]===e.TokenType.Comma){if(o===r)return-1;if(o===u){o=r;continue}return-1}o.push(a)}}const a=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),t));if(-1===a)return-1;const s=solve(calc$1(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],r),t));return-1===s?-1:solveATan2(o,a,s)}function tokenizeGlobals(n){const o=new Map;if(!n)return o;for(const[t,i]of n)if(e.isToken(i))o.set(t,i);else if("string"!=typeof i);else{const n=e.tokenizer({css:i}),u=n.nextToken();if(n.nextToken(),!n.endOfFile())continue;if(u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Percentage)continue;o.set(t,u)}return o}function patchNaN(o){if(-1===o)return-1;if(n.isFunctionNode(o))return o;const t=o.value;return t[0]!==e.TokenType.Number&&t[0]!==e.TokenType.Percentage&&t[0]!==e.TokenType.Dimension?o:Number.isNaN(t[4].value)?t[0]===e.TokenType.Number?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",t[2],t[3],{value:"NaN"}])]):t[0]===e.TokenType.Dimension?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",t[2],t[3],{value:"NaN"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",t[2],t[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Dimension,"1"+t[4].unit,t[2],t[3],{value:1,type:e.NumberType.Integer,unit:t[4].unit}])]):t[0]===e.TokenType.Percentage?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,"NaN",t[2],t[3],{value:"NaN"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",t[2],t[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Percentage,"1%",t[2],t[3],{value:1}])]):-1:o}function patchInfinity(o){if(-1===o)return-1;if(n.isFunctionNode(o))return o;const t=o.value;if(t[0]!==e.TokenType.Number&&t[0]!==e.TokenType.Percentage&&t[0]!==e.TokenType.Dimension)return o;if(Number.isFinite(t[4].value))return o;let i="";return Number.NEGATIVE_INFINITY===t[4].value&&(i="-"),t[0]===e.TokenType.Number?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",t[2],t[3],{value:i+"infinity"}])]):t[0]===e.TokenType.Dimension?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",t[2],t[3],{value:i+"infinity"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",t[2],t[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Dimension,"1"+t[4].unit,t[2],t[3],{value:1,type:e.NumberType.Integer,unit:t[4].unit}])]):t[0]===e.TokenType.Percentage?new n.FunctionNode([e.TokenType.Function,"calc(",t[2],t[3],{value:"calc"}],[e.TokenType.CloseParen,")",t[2],t[3],void 0],[new n.TokenNode([e.TokenType.Ident,i+"infinity",t[2],t[3],{value:i+"infinity"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Delim,"*",t[2],t[3],{value:"*"}]),new n.WhitespaceNode([[e.TokenType.Whitespace," ",t[2],t[3],void 0]]),new n.TokenNode([e.TokenType.Percentage,"1%",t[2],t[3],{value:1}])]):-1}function patchMinusZero(o){if(-1===o)return-1;if(n.isFunctionNode(o))return o;const t=o.value;return t[0]!==e.TokenType.Number&&t[0]!==e.TokenType.Percentage&&t[0]!==e.TokenType.Dimension?o:Object.is(-0,t[4].value)?("-0"===t[1]||(t[1]="-0"),o):o}function patchPrecision(o,t=13){if(-1===o)return-1;if(n.isFunctionNode(o))return o;const i=o.value;if(i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Percentage&&i[0]!==e.TokenType.Dimension)return o;if(Number.isInteger(i[4].value))return o;const u=Number(i[4].value.toFixed(t)).toString();return i[0]===e.TokenType.Number?i[1]=u:i[0]===e.TokenType.Percentage?i[1]=u+"%":i[0]===e.TokenType.Dimension&&(i[1]=u+i[4].unit),o}function patchCanonicalUnit(o){return-1===o?-1:(n.isFunctionNode(o)||o.value[0]!==e.TokenType.Dimension||(o.value=toCanonicalUnit(o.value)),o)}function patchCalcResult(e,n){let o=e;return o=patchNaN(e),o=patchInfinity(o),null!=n&&n.toCanonicalUnits&&(o=patchCanonicalUnit(o)),o=patchPrecision(o,null==n?void 0:n.precision),o=patchMinusZero(o),o}const g=new Map([["abs",abs],["acos",acos],["asin",asin],["atan",atan],["atan2",atan2],["calc",calc$1],["clamp",clamp],["cos",cos],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign],["sin",sin],["tan",tan]]);function calcFromComponentValues(e,o){const t=tokenizeGlobals(null==o?void 0:o.globals);for(let i=0;i<e.length;i++){const u=e[i];for(let e=0;e<u.length;e++){const i=u[e];if(n.isFunctionNode(i)){const n=g.get(i.getName().toLowerCase());if(n){const r=patchCalcResult(solve(n(i,t)),o);if(-1!==r){u.splice(e,1,r);continue}}}(n.isSimpleBlockNode(i)||n.isFunctionNode(i))&&i.walk(((e,i)=>{if("number"!=typeof i)return;const u=e.node;if(n.isFunctionNode(u)){const n=g.get(u.getName().toLowerCase());if(!n)return;const r=patchCalcResult(solve(n(u,t)),o);if(-1!==r)return void e.parent.value.splice(i,1,r)}}))}}return e}exports.calc=function calc(o,t){const i=e.tokenizer({css:o}),u=[];for(;!i.endOfFile();)u.push(i.nextToken());return u.push(i.nextToken()),calcFromComponentValues(n.parseCommaSeparatedListOfComponentValues(u,{}),t).map((n=>n.map((n=>e.stringify(...n.tokens()))).join(""))).join(",")},exports.calcFromComponentValues=calcFromComponentValues;
