"use strict";var e=require("@csstools/css-tokenizer"),n=require("@csstools/css-parser-algorithms");function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){const t=[];for(let o=0;o<e.inputs.length;o++){const r=e.inputs[o];if(n.isTokenNode(r)){t.push(r);continue}const u=solve(r);if(-1===u)return-1;t.push(u)}return e.operation(t)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.TokenType.Number||t[0]===e.TokenType.Dimension||t[0]===e.TokenType.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Percentage){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Dimension){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+r[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:Number.isInteger(t)?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function NaN_Token(t,o,r){if(Number.isNaN(t))return new n.TokenNode([e.TokenType.Ident,"NaN",o[2],r[3],{value:"NaN"}])}function addition(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Percentage){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Dimension&&o[4].unit.toLowerCase()===r[4].unit.toLowerCase()){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Percentage){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Dimension&&o[4].unit.toLowerCase()===r[4].unit.toLowerCase()){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function calcHandler(t,o){const r=[...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))];for(let t=0;t<r.length;t++){const u=r[t];if(!n.isTokenNode(u))continue;const i=u.value;if(i[0]!==e.TokenType.Ident)continue;const a=i[4].value.toLowerCase();switch(a){case"e":r.splice(t,1,new n.TokenNode([e.TokenType.Number,Math.E.toString(),i[2],i[3],{value:Math.E,type:e.NumberType.Number}]));break;case"pi":r.splice(t,1,new n.TokenNode([e.TokenType.Number,Math.PI.toString(),i[2],i[3],{value:Math.PI,type:e.NumberType.Number}]));break;default:if(o.has(a)){const u=o.get(a);r.splice(t,1,new n.TokenNode([e.TokenType.Number,u.toString(),i[2],i[3],{value:u,type:e.NumberType.Number}]))}}}if(1===r.length&&n.isTokenNode(r[0]))return{inputs:[r[0]],operation:unary};let u=0;for(;u<r.length;){const t=r[u];if(n.isSimpleBlockNode(t)&&t.startToken[0]===e.TokenType.OpenParen){const e=calcHandler(t,o);if(-1===e)return-1;r.splice(u,1,e)}else if(n.isFunctionNode(t))switch(t.getName().toLowerCase()){case"calc":{const e=calcHandler(t,o);if(-1===e)return-1;r.splice(u,1,e);break}default:return-1}else u++}if(u=0,1===r.length&&isCalculation(r[0]))return r[0];for(;u<r.length;){const t=r[u];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){u++;continue}const o=r[u+1];if(!o||!n.isTokenNode(o)){u++;continue}const i=o.value;if(i[0]!==e.TokenType.Delim||"*"!==i[4].value&&"/"!==i[4].value){u++;continue}const a=r[u+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"*"!==i[4].value?"/"!==i[4].value?u++:r.splice(u,3,{inputs:[t,a],operation:division}):r.splice(u,3,{inputs:[t,a],operation:multiplication})}if(u=0,1===r.length&&isCalculation(r[0]))return r[0];for(;u<r.length;){const t=r[u];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){u++;continue}const o=r[u+1];if(!o||!n.isTokenNode(o)){u++;continue}const i=o.value;if(i[0]!==e.TokenType.Delim||"+"!==i[4].value&&"-"!==i[4].value){u++;continue}const a=r[u+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"+"!==i[4].value?"-"!==i[4].value?u++:r.splice(u,3,{inputs:[t,a],operation:subtraction}):r.splice(u,3,{inputs:[t,a],operation:addition})}return 1===r.length&&isCalculation(r[0])?r[0]:-1}exports.convert=function convert(t,o){const r=e.tokenizer({css:t}),u=[];for(;!r.endOfFile();)u.push(r.nextToken());u.push(r.nextToken());const i=n.parseCommaSeparatedListOfComponentValues(u,{onParseError:e=>{throw e}});for(let e=0;e<i.length;e++){const r=i[e];for(let e=0;e<r.length;e++){const u=r[e];if(n.isFunctionNode(u)&&"calc"===u.getName().toLowerCase()){const n=calcHandler(u,o??new Map);if(-1===n)return t;const i=solve(n);if(-1===i)return t;r.splice(e,1,i)}else(n.isSimpleBlockNode(u)||n.isFunctionNode(u))&&u.walk(((e,t)=>{if("number"!=typeof t)return;const r=e.node;if(!n.isFunctionNode(r)||"calc"!==r.getName().toLowerCase())return;const u=calcHandler(r,o??new Map);if(-1===u)return;const i=solve(u);-1!==i&&e.parent.value.splice(t,1,i)}))}}return i.map((n=>n.map((n=>e.stringify(...n.tokens()))).join(""))).join(",")};
