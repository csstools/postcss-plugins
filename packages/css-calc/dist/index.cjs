"use strict";var e=require("@csstools/css-tokenizer"),n=require("@csstools/css-parser-algorithms");function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const t=[];for(let o=0;o<e.inputs.length;o++){const r=e.inputs[o];if(n.isTokenNode(r)){t.push(r);continue}const i=solve(r);if(-1===i)return-1;t.push(i)}return e.operation(t)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.TokenType.Number||t[0]===e.TokenType.Dimension||t[0]===e.TokenType.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Percentage){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Number){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Dimension){const t=o[4].value*r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+r[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:r[4].unit}])}return-1}function Infinity_Token(t,o,r){if(!Number.isFinite(t)){let i="",u=Number.POSITIVE_INFINITY;if(Number.NEGATIVE_INFINITY===t&&(i="-",u=Number.NEGATIVE_INFINITY),o[0]===e.TokenType.Number)return new n.TokenNode([o[0],i+Number.MAX_SAFE_INTEGER.toString(),o[2],r[3],{value:u,type:e.NumberType.Integer}]);if(o[0]===e.TokenType.Percentage)return new n.TokenNode([o[0],i+Number.MAX_SAFE_INTEGER.toString()+"%",o[2],r[3],{value:u}]);if(o[0]===e.TokenType.Dimension)return new n.TokenNode([o[0],i+Number.MAX_SAFE_INTEGER.toString()+o[4].unit,o[2],r[3],{value:u,unit:o[4].unit,type:e.NumberType.Integer}])}}function NaN_Token(t,o,r){if(Number.isNaN(t))return new n.TokenNode([e.TokenType.Ident,"NaN",o[2],r[3],{value:"NaN"}])}function division(t){if(2!==t.length)return-1;const o=t[0].value,r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??Infinity_Token(t,o,r)??new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:Number.isInteger(t)?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??Infinity_Token(t,o,r)??new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Number){const t=o[4].value/r[4].value;return NaN_Token(t,o,r)??Infinity_Token(t,o,r)??new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}const t=new Map([["cm",e=>e],["mm",e=>10*e],["q",e=>40*e],["in",e=>e/2.54],["pc",e=>e/2.54*6],["pt",e=>e/2.54*72],["px",e=>e/2.54*96]]),o=new Map([["cm",e=>2.54*e],["mm",e=>25.4*e],["q",e=>25.4*e*4],["in",e=>e],["pc",e=>6*e],["pt",e=>72*e],["px",e=>96*e]]),r=new Map([["cm",e=>e/10],["mm",e=>e],["q",e=>4*e],["in",e=>e/25.4],["pc",e=>e/25.4*6],["pt",e=>e/25.4*72],["px",e=>e/25.4*96]]),i=new Map([["ms",e=>e],["s",e=>e/1e3]]),u=new Map([["ms",e=>1e3*e],["s",e=>e]]),a=new Map([["cm",t],["mm",r],["in",o],["ms",i],["s",u]]);function convertUnit(n,t){if(n[0]!==e.TokenType.Dimension)return t;if(t[0]!==e.TokenType.Dimension)return t;const o=n[4].unit.toLowerCase(),r=t[4].unit.toLowerCase();if(o===r)return t;const i=a.get(r);if(!i)return t;const u=i.get(o);if(!u)return t;const s=u(t[4].value);return[e.TokenType.Dimension,s.toString()+n[4].unit,t[2],t[3],{value:s,unit:n[4].unit,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}]}function addition(t){if(2!==t.length)return-1;const o=t[0].value;let r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Percentage){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Dimension&&(r=convertUnit(o,r),o[4].unit.toLowerCase()===r[4].unit.toLowerCase())){const t=o[4].value+r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const o=t[0].value;let r=t[1].value;if(o[0]===e.TokenType.Number&&r[0]===e.TokenType.Number){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Number,t.toString(),o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number}])}if(o[0]===e.TokenType.Percentage&&r[0]===e.TokenType.Percentage){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Percentage,t.toString()+"%",o[2],r[3],{value:t}])}if(o[0]===e.TokenType.Dimension&&r[0]===e.TokenType.Dimension&&(r=convertUnit(o,r),o[4].unit.toLowerCase()===r[4].unit.toLowerCase())){const t=o[4].value-r[4].value;return new n.TokenNode([e.TokenType.Dimension,t.toString()+o[4].unit,o[2],r[3],{value:t,type:o[4].type===e.NumberType.Integer&&r[4].type===e.NumberType.Integer?e.NumberType.Integer:e.NumberType.Number,unit:o[4].unit}])}return-1}function solveMin(t,o){const r=o[0];if(!r||!n.isTokenNode(r))return-1;if(1!==new Set(o.map((e=>e.type))).size)return-1;const i=o[0].value;if(i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(o.map((e=>e.value[0]))).size)return-1;const u=o.map((e=>convertUnit(i,e.value)));if(1!==new Set(u.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=u.map((e=>e[4].value)),s=Math.min(...a),T=t.tokens();return i[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,s.toString()+i[4].unit,T[0][2],T[T.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number,unit:i[4].unit}])],operation:unary}:i[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,s.toString()+"%",T[0][2],T[T.length-1][3],{value:s}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,s.toString(),T[0][2],T[T.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveMax(t,o){const r=o[0];if(!r||!n.isTokenNode(r))return-1;if(1!==new Set(o.map((e=>e.type))).size)return-1;const i=o[0].value;if(i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Percentage)return-1;if(1!==new Set(o.map((e=>e.value[0]))).size)return-1;const u=o.map((e=>convertUnit(i,e.value)));if(1!==new Set(u.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const a=u.map((e=>e[4].value)),s=Math.max(...a),T=t.tokens();return i[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,s.toString()+i[4].unit,T[0][2],T[T.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number,unit:i[4].unit}])],operation:unary}:i[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,s.toString()+"%",T[0][2],T[T.length-1][3],{value:s}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,s.toString(),T[0][2],T[T.length-1][3],{value:s,type:Number.isInteger(s)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function solveClamp(t,o,r,i){if(!n.isTokenNode(o)||!n.isTokenNode(r)||!n.isTokenNode(i))return-1;const u=o.value,a=convertUnit(u,r.value),s=convertUnit(u,i.value);if(u[0]!==e.TokenType.Dimension&&u[0]!==e.TokenType.Number&&u[0]!==e.TokenType.Percentage)return-1;if(u[0]!==a[0])return-1;if(u[0]!==s[0])return-1;if(u[0]===e.TokenType.Dimension){if(u[4].unit.toLowerCase()!==a[4].unit.toLowerCase())return-1;if(u[4].unit.toLowerCase()!==s[4].unit.toLowerCase())return-1}const T=Math.max(u[4].value,Math.min(a[4].value,s[4].value)),p=t.tokens();return u[0]===e.TokenType.Dimension?{inputs:[new n.TokenNode([e.TokenType.Dimension,T.toString()+u[4].unit,p[0][2],p[p.length-1][3],{value:T,type:Number.isInteger(T)?e.NumberType.Integer:e.NumberType.Number,unit:u[4].unit}])],operation:unary}:u[0]===e.TokenType.Percentage?{inputs:[new n.TokenNode([e.TokenType.Percentage,T.toString()+"%",p[0][2],p[p.length-1][3],{value:T}])],operation:unary}:{inputs:[new n.TokenNode([e.TokenType.Number,T.toString(),p[0][2],p[p.length-1][3],{value:T,type:Number.isInteger(T)?e.NumberType.Integer:e.NumberType.Number}])],operation:unary}}function calc(t,o){const r=[...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))];for(let t=0;t<r.length;t++){const i=r[t];if(!n.isTokenNode(i))continue;const u=i.value;if(u[0]!==e.TokenType.Ident)continue;const a=u[4].value.toLowerCase();switch(a){case"e":r.splice(t,1,new n.TokenNode([e.TokenType.Number,Math.E.toString(),u[2],u[3],{value:Math.E,type:e.NumberType.Number}]));break;case"pi":r.splice(t,1,new n.TokenNode([e.TokenType.Number,Math.PI.toString(),u[2],u[3],{value:Math.PI,type:e.NumberType.Number}]));break;default:if(o.has(a)){const e=o.get(a);r.splice(t,1,new n.TokenNode(e))}}}if(1===r.length&&n.isTokenNode(r[0]))return{inputs:[r[0]],operation:unary};let i=0;for(;i<r.length;){const t=r[i];if(n.isSimpleBlockNode(t)&&t.startToken[0]===e.TokenType.OpenParen){const e=calc(t,o);if(-1===e)return-1;r.splice(i,1,e)}else if(n.isFunctionNode(t))switch(t.getName().toLowerCase()){case"calc":{const e=calc(t,o);if(-1===e)return-1;r.splice(i,1,e);break}case"clamp":{const e=clamp(t,o);if(-1===e)return-1;r.splice(i,1,e);break}case"min":{const e=min(t,o);if(-1===e)return-1;r.splice(i,1,e);break}case"max":{const e=max(t,o);if(-1===e)return-1;r.splice(i,1,e);break}default:return-1}else i++}if(i=0,1===r.length&&isCalculation(r[0]))return r[0];for(;i<r.length;){const t=r[i];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){i++;continue}const o=r[i+1];if(!o||!n.isTokenNode(o)){i++;continue}const u=o.value;if(u[0]!==e.TokenType.Delim||"*"!==u[4].value&&"/"!==u[4].value){i++;continue}const a=r[i+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"*"!==u[4].value?"/"!==u[4].value?i++:r.splice(i,3,{inputs:[t,a],operation:division}):r.splice(i,3,{inputs:[t,a],operation:multiplication})}if(i=0,1===r.length&&isCalculation(r[0]))return r[0];for(;i<r.length;){const t=r[i];if(!t||!n.isTokenNode(t)&&!isCalculation(t)){i++;continue}const o=r[i+1];if(!o||!n.isTokenNode(o)){i++;continue}const u=o.value;if(u[0]!==e.TokenType.Delim||"+"!==u[4].value&&"-"!==u[4].value){i++;continue}const a=r[i+2];if(!a||!n.isTokenNode(a)&&!isCalculation(a))return-1;"+"!==u[4].value?"-"!==u[4].value?i++:r.splice(i,3,{inputs:[t,a],operation:subtraction}):r.splice(i,3,{inputs:[t,a],operation:addition})}return 1===r.length&&isCalculation(r[0])?r[0]:-1}function clamp(t,o){const r=[...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],i=[],u=[],a=[];{let t=i;for(let o=0;o<r.length;o++){const s=r[o];if(n.isTokenNode(s)&&s.value[0]===e.TokenType.Comma){if(t===a)return-1;if(t===u){t=a;continue}if(t===i){t=u;continue}return-1}t.push(s)}}const s=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],i),o));if(-1===s)return-1;const T=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],u),o));if(-1===T)return-1;const p=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],a),o));return-1===p?-1:solveClamp(t,s,T,p)}function max(t,o){const r=[...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],i=[];{const t=[];let u=[];for(let o=0;o<r.length;o++){const i=r[o];n.isTokenNode(i)&&i.value[0]===e.TokenType.Comma?(t.push(u),u=[]):u.push(i)}t.push(u);for(let r=0;r<t.length;r++){const u=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],t[r]),o));if(-1===u)return-1;i.push(u)}}return solveMax(t,i)}function min(t,o){const r=[...t.value.filter((e=>!n.isCommentNode(e)&&!n.isWhitespaceNode(e)))],i=[];{const t=[];let u=[];for(let o=0;o<r.length;o++){const i=r[o];n.isTokenNode(i)&&i.value[0]===e.TokenType.Comma?(t.push(u),u=[]):u.push(i)}t.push(u);for(let r=0;r<t.length;r++){const u=solve(calc(new n.FunctionNode([e.TokenType.Function,"calc(",-1,-1,{value:"calc"}],[e.TokenType.CloseParen,")",-1,-1,void 0],t[r]),o));if(-1===u)return-1;i.push(u)}}return solveMin(t,i)}function tokenizeGlobals(n){const t=new Map;if(!n)return t;for(const[o,r]of n)if(e.isToken(r))t.set(o,r);else if("string"!=typeof r);else{const n=e.tokenizer({css:r}),i=n.nextToken();if(n.nextToken(),!n.endOfFile())continue;if(i[0]!==e.TokenType.Number&&i[0]!==e.TokenType.Dimension&&i[0]!==e.TokenType.Percentage)continue;t.set(o,i)}return t}exports.convert=function convert(t,o){const r=tokenizeGlobals(o),i=e.tokenizer({css:t}),u=[];for(;!i.endOfFile();)u.push(i.nextToken());u.push(i.nextToken());const a=n.parseCommaSeparatedListOfComponentValues(u,{onParseError:e=>{throw e}});for(let e=0;e<a.length;e++){const t=a[e];for(let e=0;e<t.length;e++){const o=t[e];if(n.isFunctionNode(o))if("calc"===o.getName().toLowerCase()){const n=solve(calc(o,r));if(-1!==n){t.splice(e,1,n);continue}}else if("clamp"===o.getName().toLowerCase()){const n=solve(clamp(o,r));if(-1!==n){t.splice(e,1,n);continue}}else if("min"===o.getName().toLowerCase()){const n=solve(min(o,r));if(-1!==n){t.splice(e,1,n);continue}}else if("max"===o.getName().toLowerCase()){const n=solve(max(o,r));if(-1!==n){t.splice(e,1,n);continue}}(n.isSimpleBlockNode(o)||n.isFunctionNode(o))&&o.walk(((e,t)=>{if("number"!=typeof t)return;const o=e.node;if(n.isFunctionNode(o))if("calc"===o.getName().toLowerCase()){const n=solve(calc(o,r));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("clamp"===o.getName().toLowerCase()){const n=solve(clamp(o,r));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("min"===o.getName().toLowerCase()){const n=solve(min(o,r));if(-1!==n)return void e.parent.value.splice(t,1,n)}else if("max"===o.getName().toLowerCase()){const n=solve(max(o,r));if(-1!==n)return void e.parent.value.splice(t,1,n)}}))}}return a.map((n=>n.map((n=>e.stringify(...n.tokens()))).join(""))).join(",")};
