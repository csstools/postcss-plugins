import{TokenType as e,NumberType as n,tokenizer as t,stringify as r}from"@csstools/css-tokenizer";import{isTokenNode as i,TokenNode as u,isCommentNode as o,isWhitespaceNode as a,isSimpleBlockNode as l,isFunctionNode as s,FunctionNode as c,parseCommaSeparatedListOfComponentValues as m}from"@csstools/css-parser-algorithms";function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const n=[];for(let t=0;t<e.inputs.length;t++){const r=e.inputs[t];if(i(r)){n.push(r);continue}const u=solve(r);if(-1===u)return-1;n.push(u)}return e.operation(n)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.Number||t[0]===e.Dimension||t[0]===e.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const r=t[0].value,i=t[1].value;if(r[0]===e.Number&&i[0]===e.Number){const t=r[4].value*i[4].value;return new u([e.Number,t.toString(),r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&i[0]===e.Number){const n=r[4].value*i[4].value;return new u([e.Percentage,n.toString()+"%",r[2],i[3],{value:n}])}if(r[0]===e.Number&&i[0]===e.Percentage){const n=r[4].value*i[4].value;return new u([e.Percentage,n.toString()+"%",r[2],i[3],{value:n}])}if(r[0]===e.Dimension&&i[0]===e.Number){const t=r[4].value*i[4].value;return new u([e.Dimension,t.toString()+r[4].unit,r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}if(r[0]===e.Number&&i[0]===e.Dimension){const t=r[4].value*i[4].value;return new u([e.Dimension,t.toString()+i[4].unit,r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number,unit:i[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const r=t[0].value,i=t[1].value;if(r[0]===e.Number&&i[0]===e.Number){const t=r[4].value/i[4].value;return NaN_Token(t,r,i)??Infinity_Token(t,r,i)??new u([e.Number,t.toString(),r[2],i[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number}])}if(r[0]===e.Percentage&&i[0]===e.Number){const n=r[4].value/i[4].value;return NaN_Token(n,r,i)??Infinity_Token(n,r,i)??new u([e.Percentage,n.toString()+"%",r[2],i[3],{value:n}])}if(r[0]===e.Dimension&&i[0]===e.Number){const t=r[4].value/i[4].value;return NaN_Token(t,r,i)??Infinity_Token(t,r,i)??new u([e.Dimension,t.toString()+r[4].unit,r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function NaN_Token(n,t,r){if(Number.isNaN(n))return new u([e.Ident,"NaN",t[2],r[3],{value:"NaN"}])}function Infinity_Token(t,r,i){if(!Number.isFinite(t)){let o="",a=Number.POSITIVE_INFINITY;if(Number.NEGATIVE_INFINITY===t&&(o="-",a=Number.NEGATIVE_INFINITY),r[0]===e.Number)return new u([r[0],o+Number.MAX_SAFE_INTEGER.toString(),r[2],i[3],{value:a,type:n.Integer}]);if(r[0]===e.Percentage)return new u([r[0],o+Number.MAX_SAFE_INTEGER.toString()+"%",r[2],i[3],{value:a}]);if(r[0]===e.Dimension)return new u([r[0],o+Number.MAX_SAFE_INTEGER.toString()+r[4].unit,r[2],i[3],{value:a,unit:r[4].unit,type:n.Integer}])}}function addition(t){if(2!==t.length)return-1;const r=t[0].value,i=t[1].value;if(r[0]===e.Number&&i[0]===e.Number){const t=r[4].value+i[4].value;return new u([e.Number,t.toString(),r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&i[0]===e.Percentage){const n=r[4].value+i[4].value;return new u([e.Percentage,n.toString()+"%",r[2],i[3],{value:n}])}if(r[0]===e.Dimension&&i[0]===e.Dimension&&r[4].unit.toLowerCase()===i[4].unit.toLowerCase()){const t=r[4].value+i[4].value;return new u([e.Dimension,t.toString()+r[4].unit,r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const r=t[0].value,i=t[1].value;if(r[0]===e.Number&&i[0]===e.Number){const t=r[4].value-i[4].value;return new u([e.Number,t.toString(),r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&i[0]===e.Percentage){const n=r[4].value-i[4].value;return new u([e.Percentage,n.toString()+"%",r[2],i[3],{value:n}])}if(r[0]===e.Dimension&&i[0]===e.Dimension&&r[4].unit.toLowerCase()===i[4].unit.toLowerCase()){const t=r[4].value-i[4].value;return new u([e.Dimension,t.toString()+r[4].unit,r[2],i[3],{value:t,type:r[4].type===n.Integer&&i[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function calc(t,r){const c=[...t.value.filter((e=>!o(e)&&!a(e)))];for(let t=0;t<c.length;t++){const o=c[t];if(!i(o))continue;const a=o.value;if(a[0]!==e.Ident)continue;const l=a[4].value.toLowerCase();switch(l){case"e":c.splice(t,1,new u([e.Number,Math.E.toString(),a[2],a[3],{value:Math.E,type:n.Number}]));break;case"pi":c.splice(t,1,new u([e.Number,Math.PI.toString(),a[2],a[3],{value:Math.PI,type:n.Number}]));break;default:if(r.has(l)){const i=r.get(l);c.splice(t,1,new u([e.Number,i.toString(),a[2],a[3],{value:i,type:n.Number}]))}}}if(1===c.length&&i(c[0]))return{inputs:[c[0]],operation:unary};let m=0;for(;m<c.length;){const n=c[m];if(l(n)&&n.startToken[0]===e.OpenParen){const e=calc(n,r);if(-1===e)return-1;c.splice(m,1,e)}else if(s(n))switch(n.getName().toLowerCase()){case"calc":{const e=calc(n,r);if(-1===e)return-1;c.splice(m,1,e);break}case"clamp":{const e=clamp(n,r);if(-1===e)return-1;c.splice(m,1,e);break}case"min":{const e=min(n,r);if(-1===e)return-1;c.splice(m,1,e);break}case"max":{const e=max(n,r);if(-1===e)return-1;c.splice(m,1,e);break}default:return-1}else m++}if(m=0,1===c.length&&isCalculation(c[0]))return c[0];for(;m<c.length;){const n=c[m];if(!n||!i(n)&&!isCalculation(n)){m++;continue}const t=c[m+1];if(!t||!i(t)){m++;continue}const r=t.value;if(r[0]!==e.Delim||"*"!==r[4].value&&"/"!==r[4].value){m++;continue}const u=c[m+2];if(!u||!i(u)&&!isCalculation(u))return-1;"*"!==r[4].value?"/"!==r[4].value?m++:c.splice(m,3,{inputs:[n,u],operation:division}):c.splice(m,3,{inputs:[n,u],operation:multiplication})}if(m=0,1===c.length&&isCalculation(c[0]))return c[0];for(;m<c.length;){const n=c[m];if(!n||!i(n)&&!isCalculation(n)){m++;continue}const t=c[m+1];if(!t||!i(t)){m++;continue}const r=t.value;if(r[0]!==e.Delim||"+"!==r[4].value&&"-"!==r[4].value){m++;continue}const u=c[m+2];if(!u||!i(u)&&!isCalculation(u))return-1;"+"!==r[4].value?"-"!==r[4].value?m++:c.splice(m,3,{inputs:[n,u],operation:subtraction}):c.splice(m,3,{inputs:[n,u],operation:addition})}return 1===c.length&&isCalculation(c[0])?c[0]:-1}function clamp(t,r){const l=[...t.value.filter((e=>!o(e)&&!a(e)))],s=[],m=[],p=[];{let n=s;for(let t=0;t<l.length;t++){const r=l[t];if(i(r)&&r.value[0]===e.Comma){if(n===p)return-1;if(n===m){n=p;continue}if(n===s){n=m;continue}return-1}n.push(r)}}const v=solve(calc(new c([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],s),r));if(-1===v)return-1;const f=solve(calc(new c([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],m),r));if(-1===f)return-1;const g=solve(calc(new c([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],p),r));if(-1===g)return-1;if(!i(v)||!i(f)||!i(g))return-1;const N=v.value,w=f.value,b=g.value;if(N[0]!==e.Dimension&&N[0]!==e.Number&&N[0]!==e.Percentage)return-1;if(N[0]!==w[0])return-1;if(N[0]!==b[0])return-1;if(N[0]===e.Dimension){if(N[4].unit.toLowerCase()!==w[4].unit.toLowerCase())return-1;if(N[4].unit.toLowerCase()!==b[4].unit.toLowerCase())return-1}const I=Math.max(N[4].value,Math.min(w[4].value,b[4].value)),h=t.tokens();return N[0]===e.Dimension?{inputs:[new u([e.Dimension,I.toString()+N[4].unit,h[0][2],h[h.length-1][3],{value:I,type:Number.isInteger(I)?n.Integer:n.Number,unit:N[4].unit}])],operation:unary}:N[0]===e.Percentage?{inputs:[new u([e.Percentage,I.toString()+"%",h[0][2],h[h.length-1][3],{value:I}])],operation:unary}:{inputs:[new u([e.Number,I.toString(),h[0][2],h[h.length-1][3],{value:I,type:Number.isInteger(I)?n.Integer:n.Number}])],operation:unary}}function max(t,r){const l=[...t.value.filter((e=>!o(e)&&!a(e)))],s=[];{const n=[];let t=[];for(let r=0;r<l.length;r++){const u=l[r];i(u)&&u.value[0]===e.Comma?(n.push(t),t=[]):t.push(u)}n.push(t);for(let t=0;t<n.length;t++){const i=solve(calc(new c([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[t]),r));if(-1===i)return-1;s.push(i)}}const m=s[0];if(!m||!i(m))return-1;if(1!==new Set(s.map((e=>e.type))).size)return-1;const p=s[0].value;if(p[0]!==e.Dimension&&p[0]!==e.Number&&p[0]!==e.Percentage)return-1;if(1!==new Set(s.map((e=>e.value[0]))).size)return-1;if(1!==new Set(s.map((e=>(e.value[4].unit??"").toLowerCase()))).size)return-1;const v=s.map((e=>e.value[4].value)),f=Math.max(...v),g=t.tokens();return p[0]===e.Dimension?{inputs:[new u([e.Dimension,f.toString()+p[4].unit,g[0][2],g[g.length-1][3],{value:f,type:Number.isInteger(f)?n.Integer:n.Number,unit:p[4].unit}])],operation:unary}:p[0]===e.Percentage?{inputs:[new u([e.Percentage,f.toString()+"%",g[0][2],g[g.length-1][3],{value:f}])],operation:unary}:{inputs:[new u([e.Number,f.toString(),g[0][2],g[g.length-1][3],{value:f,type:Number.isInteger(f)?n.Integer:n.Number}])],operation:unary}}function min(t,r){const l=[...t.value.filter((e=>!o(e)&&!a(e)))],s=[];{const n=[];let t=[];for(let r=0;r<l.length;r++){const u=l[r];i(u)&&u.value[0]===e.Comma?(n.push(t),t=[]):t.push(u)}n.push(t);for(let t=0;t<n.length;t++){const i=solve(calc(new c([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[t]),r));if(-1===i)return-1;s.push(i)}}const m=s[0];if(!m||!i(m))return-1;if(1!==new Set(s.map((e=>e.type))).size)return-1;const p=s[0].value;if(p[0]!==e.Dimension&&p[0]!==e.Number&&p[0]!==e.Percentage)return-1;if(1!==new Set(s.map((e=>e.value[0]))).size)return-1;if(1!==new Set(s.map((e=>(e.value[4].unit??"").toLowerCase()))).size)return-1;const v=s.map((e=>e.value[4].value)),f=Math.min(...v),g=t.tokens();return p[0]===e.Dimension?{inputs:[new u([e.Dimension,f.toString()+p[4].unit,g[0][2],g[g.length-1][3],{value:f,type:Number.isInteger(f)?n.Integer:n.Number,unit:p[4].unit}])],operation:unary}:p[0]===e.Percentage?{inputs:[new u([e.Percentage,f.toString()+"%",g[0][2],g[g.length-1][3],{value:f}])],operation:unary}:{inputs:[new u([e.Number,f.toString(),g[0][2],g[g.length-1][3],{value:f,type:Number.isInteger(f)?n.Integer:n.Number}])],operation:unary}}function convert(e,n){const i=t({css:e}),u=[];for(;!i.endOfFile();)u.push(i.nextToken());u.push(i.nextToken());const o=m(u,{onParseError:e=>{throw e}});for(let e=0;e<o.length;e++){const t=o[e];for(let e=0;e<t.length;e++){const r=t[e];if(s(r))if("calc"===r.getName().toLowerCase()){const i=solve(calc(r,n??new Map));if(-1!==i){t.splice(e,1,i);continue}}else if("clamp"===r.getName().toLowerCase()){const i=solve(clamp(r,n??new Map));if(-1!==i){t.splice(e,1,i);continue}}else if("min"===r.getName().toLowerCase()){const i=solve(min(r,n??new Map));if(-1!==i){t.splice(e,1,i);continue}}else if("max"===r.getName().toLowerCase()){const i=solve(max(r,n??new Map));if(-1!==i){t.splice(e,1,i);continue}}(l(r)||s(r))&&r.walk(((e,t)=>{if("number"!=typeof t)return;const r=e.node;if(s(r))if("calc"===r.getName().toLowerCase()){const i=solve(calc(r,n??new Map));if(-1!==i)return void e.parent.value.splice(t,1,i)}else if("clamp"===r.getName().toLowerCase()){const i=solve(clamp(r,n??new Map));if(-1!==i)return void e.parent.value.splice(t,1,i)}else if("min"===r.getName().toLowerCase()){const i=solve(min(r,n??new Map));if(-1!==i)return void e.parent.value.splice(t,1,i)}else if("max"===r.getName().toLowerCase()){const i=solve(max(r,n??new Map));if(-1!==i)return void e.parent.value.splice(t,1,i)}}))}}return o.map((e=>e.map((e=>r(...e.tokens()))).join(""))).join(",")}export{convert};
