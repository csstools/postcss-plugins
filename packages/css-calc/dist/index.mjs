import{TokenType as e,NumberType as n,isToken as t,tokenizer as u,stringify as r}from"@csstools/css-tokenizer";import{isTokenNode as a,TokenNode as i,isCommentNode as o,isWhitespaceNode as l,isSimpleBlockNode as s,isFunctionNode as c,FunctionNode as v,WhitespaceNode as m,parseCommaSeparatedListOfComponentValues as f}from"@csstools/css-parser-algorithms";function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const n=[];for(let t=0;t<e.inputs.length;t++){const u=e.inputs[t];if(a(u)){n.push(u);continue}const r=solve(u);if(-1===r)return-1;n.push(r)}return e.operation(n)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.Number||t[0]===e.Dimension||t[0]===e.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const u=t[0].value,r=t[1].value;if(u[0]===e.Number&&r[0]===e.Number){const t=u[4].value*r[4].value;return new i([e.Number,t.toString(),u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number}])}if(u[0]===e.Percentage&&r[0]===e.Number){const n=u[4].value*r[4].value;return new i([e.Percentage,n.toString()+"%",u[2],r[3],{value:n}])}if(u[0]===e.Number&&r[0]===e.Percentage){const n=u[4].value*r[4].value;return new i([e.Percentage,n.toString()+"%",u[2],r[3],{value:n}])}if(u[0]===e.Dimension&&r[0]===e.Number){const t=u[4].value*r[4].value;return new i([e.Dimension,t.toString()+u[4].unit,u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number,unit:u[4].unit}])}if(u[0]===e.Number&&r[0]===e.Dimension){const t=u[4].value*r[4].value;return new i([e.Dimension,t.toString()+r[4].unit,u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const u=t[0].value,r=t[1].value;if(u[0]===e.Number&&r[0]===e.Number){const t=u[4].value/r[4].value;return new i([e.Number,t.toString(),u[2],r[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number}])}if(u[0]===e.Percentage&&r[0]===e.Number){const n=u[4].value/r[4].value;return new i([e.Percentage,n.toString()+"%",u[2],r[3],{value:n}])}if(u[0]===e.Dimension&&r[0]===e.Number){const t=u[4].value/r[4].value;return new i([e.Dimension,t.toString()+u[4].unit,u[2],r[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number,unit:u[4].unit}])}return-1}const p=new Map([["cm",e=>e],["mm",e=>10*e],["q",e=>40*e],["in",e=>e/2.54],["pc",e=>e/2.54*6],["pt",e=>e/2.54*72],["px",e=>e/2.54*96]]),g=new Map([["deg",e=>e],["grad",e=>e/.9],["rad",e=>e/180*Math.PI],["turn",e=>e/360]]),b=new Map([["deg",e=>.9*e],["grad",e=>e],["rad",e=>.9*e/180*Math.PI],["turn",e=>.9*e/360]]),N=new Map([["hz",e=>e],["khz",e=>e/1e3]]),w=new Map([["cm",e=>2.54*e],["mm",e=>25.4*e],["q",e=>25.4*e*4],["in",e=>e],["pc",e=>6*e],["pt",e=>72*e],["px",e=>96*e]]),d=new Map([["hz",e=>1e3*e],["khz",e=>e]]),h=new Map([["cm",e=>e/10],["mm",e=>e],["q",e=>4*e],["in",e=>e/25.4],["pc",e=>e/25.4*6],["pt",e=>e/25.4*72],["px",e=>e/25.4*96]]),C=new Map([["ms",e=>e],["s",e=>e/1e3]]),I=new Map([["cm",e=>e/6*2.54],["mm",e=>e/6*25.4],["q",e=>e/6*25.4*4],["in",e=>e/6],["pc",e=>e],["pt",e=>e/6*72],["px",e=>e/6*96]]),P=new Map([["cm",e=>e/72*2.54],["mm",e=>e/72*25.4],["q",e=>e/72*25.4*4],["in",e=>e/72],["pc",e=>e/72*6],["pt",e=>e],["px",e=>e/72*96]]),y=new Map([["cm",e=>e/96*2.54],["mm",e=>e/96*25.4],["q",e=>e/96*25.4*4],["in",e=>e/96],["pc",e=>e/96*6],["pt",e=>e/96*72],["px",e=>e]]),M=new Map([["cm",e=>e/4/10],["mm",e=>e/4],["q",e=>e],["in",e=>e/4/25.4],["pc",e=>e/4/25.4*6],["pt",e=>e/4/25.4*72],["px",e=>e/4/25.4*96]]),D=new Map([["deg",e=>180*e/Math.PI],["grad",e=>180*e/Math.PI/.9],["rad",e=>e],["turn",e=>180*e/Math.PI/360]]),F=new Map([["ms",e=>1e3*e],["s",e=>e]]),k=new Map([["deg",e=>360*e],["grad",e=>360*e/.9],["rad",e=>360*e/180*Math.PI],["turn",e=>e]]),S=new Map([["cm",p],["mm",h],["q",M],["in",w],["pc",I],["pt",P],["px",y],["ms",C],["s",F],["deg",g],["grad",b],["rad",D],["turn",k],["hz",N],["khz",d]]);function convertUnit(t,u){if(t[0]!==e.Dimension)return u;if(u[0]!==e.Dimension)return u;const r=t[4].unit.toLowerCase(),a=u[4].unit.toLowerCase();if(r===a)return u;const i=S.get(a);if(!i)return u;const o=i.get(r);if(!o)return u;const l=o(u[4].value);return[e.Dimension,l.toString()+t[4].unit,u[2],u[3],{value:l,unit:t[4].unit,type:Number.isInteger(l)?n.Integer:n.Number}]}function addition(t){if(2!==t.length)return-1;const u=t[0].value;let r=t[1].value;if(u[0]===e.Number&&r[0]===e.Number){const t=u[4].value+r[4].value;return new i([e.Number,t.toString(),u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number}])}if(u[0]===e.Percentage&&r[0]===e.Percentage){const n=u[4].value+r[4].value;return new i([e.Percentage,n.toString()+"%",u[2],r[3],{value:n}])}if(u[0]===e.Dimension&&r[0]===e.Dimension&&(r=convertUnit(u,r),u[4].unit.toLowerCase()===r[4].unit.toLowerCase())){const t=u[4].value+r[4].value;return new i([e.Dimension,t.toString()+u[4].unit,u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number,unit:u[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const u=t[0].value;let r=t[1].value;if(u[0]===e.Number&&r[0]===e.Number){const t=u[4].value-r[4].value;return new i([e.Number,t.toString(),u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number}])}if(u[0]===e.Percentage&&r[0]===e.Percentage){const n=u[4].value-r[4].value;return new i([e.Percentage,n.toString()+"%",u[2],r[3],{value:n}])}if(u[0]===e.Dimension&&r[0]===e.Dimension&&(r=convertUnit(u,r),u[4].unit.toLowerCase()===r[4].unit.toLowerCase())){const t=u[4].value-r[4].value;return new i([e.Dimension,t.toString()+u[4].unit,u[2],r[3],{value:t,type:u[4].type===n.Integer&&r[4].type===n.Integer?n.Integer:n.Number,unit:u[4].unit}])}return-1}function resultToCalculation(t,u,r){const a=t.tokens();return u[0]===e.Dimension?{inputs:[new i([e.Dimension,r.toString()+u[4].unit,a[0][2],a[a.length-1][3],{value:r,type:Number.isInteger(r)?n.Integer:n.Number,unit:u[4].unit}])],operation:unary}:u[0]===e.Percentage?{inputs:[new i([e.Percentage,r.toString()+"%",a[0][2],a[a.length-1][3],{value:r}])],operation:unary}:{inputs:[new i([e.Number,r.toString(),a[0][2],a[a.length-1][3],{value:r,type:Number.isInteger(r)?n.Integer:n.Number}])],operation:unary}}function solveMin(n,t){const u=t[0];if(!u||!a(u))return-1;if(1!==new Set(t.map((e=>e.type))).size)return-1;const r=t[0].value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;if(1!==new Set(t.map((e=>e.value[0]))).size)return-1;const i=t.map((e=>convertUnit(r,e.value)));if(1!==new Set(i.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const o=i.map((e=>e[4].value)),l=Math.min(...o);return resultToCalculation(n,r,l)}function solveMax(n,t){const u=t[0];if(!u||!a(u))return-1;if(1!==new Set(t.map((e=>e.type))).size)return-1;const r=t[0].value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;if(1!==new Set(t.map((e=>e.value[0]))).size)return-1;const i=t.map((e=>convertUnit(r,e.value)));if(1!==new Set(i.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const o=i.map((e=>e[4].value)),l=Math.max(...o);return resultToCalculation(n,r,l)}function solveClamp(n,t,u,r){if(!a(t)||!a(u)||!a(r))return-1;const i=t.value,o=convertUnit(i,u.value),l=convertUnit(i,r.value);if(i[0]!==e.Dimension&&i[0]!==e.Number&&i[0]!==e.Percentage)return-1;if(i[0]!==o[0])return-1;if(i[0]!==l[0])return-1;if(i[0]===e.Dimension){if(i[4].unit.toLowerCase()!==o[4].unit.toLowerCase())return-1;if(i[4].unit.toLowerCase()!==l[4].unit.toLowerCase())return-1}return resultToCalculation(n,i,Math.max(i[4].value,Math.min(o[4].value,l[4].value)))}function resolveGlobalsAndConstants(t,u){for(let r=0;r<t.length;r++){const o=t[r];if(!a(o))continue;const l=o.value;if(l[0]!==e.Ident)continue;const s=l[4].value.toLowerCase();switch(s){case"e":t.splice(r,1,new i([e.Number,Math.E.toString(),l[2],l[3],{value:Math.E,type:n.Number}]));break;case"pi":t.splice(r,1,new i([e.Number,Math.PI.toString(),l[2],l[3],{value:Math.PI,type:n.Number}]));break;case"infinity":t.splice(r,1,new i([e.Number,"infinity",l[2],l[3],{value:1/0,type:n.Number}]));break;case"-infinity":t.splice(r,1,new i([e.Number,"-infinity",l[2],l[3],{value:-1/0,type:n.Number}]));break;case"nan":t.splice(r,1,new i([e.Number,"NaN",l[2],l[3],{value:Number.NaN,type:n.Number}]));break;default:if(u.has(s)){const e=u.get(s);t.splice(r,1,new i(e))}}}return t}function solveRound(n,t,u,r){const a=u.value;if(a[0]!==e.Dimension&&a[0]!==e.Number&&a[0]!==e.Percentage)return-1;const i=convertUnit(a,r.value);if(a[0]!==i[0])return-1;if(a[0]===e.Dimension&&a[4].unit!==i[4].unit)return-1;let o;if(0===i[4].value)o=Number.NaN;else if(Number.isFinite(a[4].value)||Number.isFinite(i[4].value))if(!Number.isFinite(a[4].value)&&Number.isFinite(i[4].value))o=a[4].value;else if(Number.isFinite(a[4].value)&&!Number.isFinite(i[4].value))switch(t){case"down":o=a[4].value<0?-1/0:Object.is(-0,0*a[4].value)?-0:0;break;case"up":o=a[4].value>0?1/0:Object.is(0,0*a[4].value)?0:-0;break;default:o=Object.is(0,0*a[4].value)?0:-0}else if(Number.isFinite(i[4].value))switch(t){case"down":o=Math.floor(a[4].value/i[4].value)*i[4].value;break;case"up":o=Math.ceil(a[4].value/i[4].value)*i[4].value;break;case"to-zero":o=Math.trunc(a[4].value/i[4].value)*i[4].value;break;default:{let e=Math.floor(a[4].value/i[4].value)*i[4].value,n=Math.ceil(a[4].value/i[4].value)*i[4].value;if(e>n){const t=e;e=n,n=t}const t=Math.abs(a[4].value-e),u=Math.abs(a[4].value-n);t===u&&(o=n),o=t<u?e:n;break}}else o=a[4].value;else o=Number.NaN;return resultToCalculation(n,a,o)}function solveMod(n,t,u){const r=t.value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;const a=convertUnit(r,u.value);if(r[0]!==a[0])return-1;if(r[0]===e.Dimension&&r[4].unit!==a[4].unit)return-1;let i;return i=0===a[4].value?Number.NaN:Number.isFinite(r[4].value)&&(Number.isFinite(a[4].value)||(a[4].value!==Number.POSITIVE_INFINITY||r[4].value!==Number.NEGATIVE_INFINITY&&!Object.is(0*r[4].value,-0))&&(a[4].value!==Number.NEGATIVE_INFINITY||r[4].value!==Number.POSITIVE_INFINITY&&!Object.is(0*r[4].value,0)))?Number.isFinite(a[4].value)?(r[4].value%a[4].value+a[4].value)%a[4].value:r[4].value:Number.NaN,resultToCalculation(n,r,i)}function solveRem(n,t,u){const r=t.value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;const a=convertUnit(r,u.value);if(r[0]!==a[0])return-1;if(r[0]===e.Dimension&&r[4].unit!==a[4].unit)return-1;let i;return i=0===a[4].value?Number.NaN:Number.isFinite(r[4].value)?Number.isFinite(a[4].value)?r[4].value%a[4].value:r[4].value:Number.NaN,resultToCalculation(n,r,i)}function solveAbs(n,t){const u=t.value;if(u[0]!==e.Dimension&&u[0]!==e.Number)return-1;return resultToCalculation(n,u,Math.abs(u[4].value))}function solveSign(t,u){const r=u.value;if(r[0]!==e.Dimension&&r[0]!==e.Number)return-1;const a=Math.sign(r[4].value),o=t.tokens();return{inputs:[new i([e.Number,a.toString(),o[0][2],o[o.length-1][3],{value:a,type:Number.isInteger(a)?n.Integer:n.Number}])],operation:unary}}function solveSin(t,u){const r=u.value;if(r[0]!==e.Dimension&&r[0]!==e.Number)return-1;if(r[0]===e.Dimension)switch(r[4].unit.toLowerCase()){case"rad":break;case"deg":r[4].value=g.get("rad")(r[4].value);break;case"grad":r[4].value=b.get("rad")(r[4].value);break;case"turn":r[4].value=k.get("rad")(r[4].value);break;default:return-1}const a=Math.sin(r[4].value),o=t.tokens();return{inputs:[new i([e.Number,a.toString(),o[0][2],o[o.length-1][3],{value:a,type:Number.isInteger(a)?n.Integer:n.Number}])],operation:unary}}function solveCos(t,u){const r=u.value;if(r[0]!==e.Dimension&&r[0]!==e.Number)return-1;if(r[0]===e.Dimension)switch(r[4].unit.toLowerCase()){case"rad":break;case"deg":r[4].value=g.get("rad")(r[4].value);break;case"grad":r[4].value=b.get("rad")(r[4].value);break;case"turn":r[4].value=k.get("rad")(r[4].value);break;default:return-1}const a=Math.cos(r[4].value),o=t.tokens();return{inputs:[new i([e.Number,a.toString(),o[0][2],o[o.length-1][3],{value:a,type:Number.isInteger(a)?n.Integer:n.Number}])],operation:unary}}function solveTan(t,u){const r=u.value;if(r[0]!==e.Dimension&&r[0]!==e.Number)return-1;const a=r[4].value;let o=0;if(r[0]===e.Dimension)switch(r[4].unit.toLowerCase()){case"rad":o=D.get("deg")(a);break;case"deg":o=a,r[4].value=g.get("rad")(a);break;case"grad":o=b.get("deg")(a),r[4].value=b.get("rad")(a);break;case"turn":o=k.get("deg")(a),r[4].value=k.get("rad")(a);break;default:return-1}const l=o/90;let s;s=o%90==0&&l%2!=0?l>0?1/0:-1/0:Math.tan(r[4].value);const c=t.tokens();return{inputs:[new i([e.Number,s.toString(),c[0][2],c[c.length-1][3],{value:s,type:Number.isInteger(s)?n.Integer:n.Number}])],operation:unary}}const T=new Map([["abs",abs],["calc",calc],["clamp",clamp],["cos",cos],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign],["sin",sin],["tan",tan]]);function calc(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t);if(1===u.length&&a(u[0]))return{inputs:[u[0]],operation:unary};let r=0;for(;r<u.length;){const n=u[r];if(s(n)&&n.startToken[0]===e.OpenParen){const e=calc(n,t);if(-1===e)return-1;u.splice(r,1,e)}else if(c(n)){const e=T.get(n.getName().toLowerCase());if(!e)return-1;{const a=e(n,t);if(-1===a)return-1;u.splice(r,1,a)}}else r++}if(r=0,1===u.length&&isCalculation(u[0]))return u[0];for(;r<u.length;){const n=u[r];if(!n||!a(n)&&!isCalculation(n)){r++;continue}const t=u[r+1];if(!t||!a(t)){r++;continue}const i=t.value;if(i[0]!==e.Delim||"*"!==i[4].value&&"/"!==i[4].value){r++;continue}const o=u[r+2];if(!o||!a(o)&&!isCalculation(o))return-1;"*"!==i[4].value?"/"!==i[4].value?r++:u.splice(r,3,{inputs:[n,o],operation:division}):u.splice(r,3,{inputs:[n,o],operation:multiplication})}if(r=0,1===u.length&&isCalculation(u[0]))return u[0];for(;r<u.length;){const n=u[r];if(!n||!a(n)&&!isCalculation(n)){r++;continue}const t=u[r+1];if(!t||!a(t)){r++;continue}const i=t.value;if(i[0]!==e.Delim||"+"!==i[4].value&&"-"!==i[4].value){r++;continue}const o=u[r+2];if(!o||!a(o)&&!isCalculation(o))return-1;"+"!==i[4].value?"-"!==i[4].value?r++:u.splice(r,3,{inputs:[n,o],operation:subtraction}):u.splice(r,3,{inputs:[n,o],operation:addition})}return 1===u.length&&isCalculation(u[0])?u[0]:-1}function clamp(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=[],i=[],s=[];{let n=r;for(let t=0;t<u.length;t++){const o=u[t];if(a(o)&&o.value[0]===e.Comma){if(n===s)return-1;if(n===i){n=s;continue}if(n===r){n=i;continue}return-1}n.push(o)}}const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],r),t));if(-1===c)return-1;const m=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));if(-1===m)return-1;const f=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],s),t));return-1===f?-1:solveClamp(n,c,m,f)}function max(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=[];{const n=[];let i=[];for(let t=0;t<u.length;t++){const r=u[t];a(r)&&r.value[0]===e.Comma?(n.push(i),i=[]):i.push(r)}n.push(i);for(let u=0;u<n.length;u++){if(0===n[u].length)return-1;const a=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[u]),t));if(-1===a)return-1;r.push(a)}}return solveMax(n,r)}function min(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=[];{const n=[];let i=[];for(let t=0;t<u.length;t++){const r=u[t];a(r)&&r.value[0]===e.Comma?(n.push(i),i=[]):i.push(r)}n.push(i);for(let u=0;u<n.length;u++){if(0===n[u].length)return-1;const a=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[u]),t));if(-1===a)return-1;r.push(a)}}return solveMin(n,r)}const x=new Set(["nearest","up","down","to-zero"]);function round(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t);let r="";const i=[],s=[];{let n=i;for(let t=0;t<u.length;t++){const o=u[t];if(!r&&0===i.length&&0===s.length&&a(o)&&o.value[0]===e.Ident){const e=o.value;if(x.has(e[4].value.toLowerCase())){r=e[4].value.toLowerCase();continue}}if(a(o)&&o.value[0]===e.Comma){if(n===s)return-1;if(n===i&&r&&0===i.length)continue;if(n===i){n=s;continue}return-1}n.push(o)}}const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));if(-1===c)return-1;const m=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],s),t));return-1===m?-1:(r||(r="nearest"),solveRound(n,r,c,m))}function mod(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=[],i=[];{let n=r;for(let t=0;t<u.length;t++){const o=u[t];if(a(o)&&o.value[0]===e.Comma){if(n===i)return-1;if(n===r){n=i;continue}return-1}n.push(o)}}const s=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],r),t));if(-1===s)return-1;const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));return-1===c?-1:solveMod(n,s,c)}function rem(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=[],i=[];{let n=r;for(let t=0;t<u.length;t++){const o=u[t];if(a(o)&&o.value[0]===e.Comma){if(n===i)return-1;if(n===r){n=i;continue}return-1}n.push(o)}}const s=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],r),t));if(-1===s)return-1;const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));return-1===c?-1:solveRem(n,s,c)}function abs(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));return-1===r?-1:solveAbs(n,r)}function sign(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));return-1===r?-1:solveSign(n,r)}function sin(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));return-1===r?-1:solveSin(n,r)}function cos(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));return-1===r?-1:solveCos(n,r)}function tan(n,t){const u=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));return-1===r?-1:solveTan(n,r)}function tokenizeGlobals(n){const r=new Map;if(!n)return r;for(const[a,i]of n)if(t(i))r.set(a,i);else if("string"!=typeof i);else{const n=u({css:i}),t=n.nextToken();if(n.nextToken(),!n.endOfFile())continue;if(t[0]!==e.Number&&t[0]!==e.Dimension&&t[0]!==e.Percentage)continue;r.set(a,t)}return r}function patchNaN(t){if(-1===t)return-1;if(c(t))return t;const u=t.value;return u[0]!==e.Number&&u[0]!==e.Percentage&&u[0]!==e.Dimension?t:Number.isNaN(u[4].value)?u[0]===e.Number?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,"NaN",u[2],u[3],{value:"NaN"}])]):u[0]===e.Dimension?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,"NaN",u[2],u[3],{value:"NaN"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Delim,"*",u[2],u[3],{value:"*"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Dimension,"1"+u[4].unit,u[2],u[3],{value:1,type:n.Integer,unit:u[4].unit}])]):u[0]===e.Percentage?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,"NaN",u[2],u[3],{value:"NaN"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Delim,"*",u[2],u[3],{value:"*"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Percentage,"1%",u[2],u[3],{value:1}])]):-1:t}function patchInfinity(t){if(-1===t)return-1;if(c(t))return t;const u=t.value;if(u[0]!==e.Number&&u[0]!==e.Percentage&&u[0]!==e.Dimension)return t;if(Number.isFinite(u[4].value))return t;let r="";return Number.NEGATIVE_INFINITY===u[4].value&&(r="-"),u[0]===e.Number?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,r+"infinity",u[2],u[3],{value:r+"infinity"}])]):u[0]===e.Dimension?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,r+"infinity",u[2],u[3],{value:r+"infinity"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Delim,"*",u[2],u[3],{value:"*"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Dimension,"1"+u[4].unit,u[2],u[3],{value:1,type:n.Integer,unit:u[4].unit}])]):u[0]===e.Percentage?new v([e.Function,"calc(",u[2],u[3],{value:"calc"}],[e.CloseParen,")",u[2],u[3],void 0],[new i([e.Ident,r+"infinity",u[2],u[3],{value:r+"infinity"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Delim,"*",u[2],u[3],{value:"*"}]),new m([[e.Whitespace," ",u[2],u[3],void 0]]),new i([e.Percentage,"1%",u[2],u[3],{value:1}])]):-1}function patchMinusZero(n){if(-1===n)return-1;if(c(n))return n;const t=n.value;return t[0]!==e.Number&&t[0]!==e.Percentage&&t[0]!==e.Dimension?n:Object.is(-0,t[4].value)?("-0"===t[1]||(t[1]="-0"),n):n}function patchPrecision(n,t=13){if(-1===n)return-1;if(c(n))return n;const u=n.value;if(u[0]!==e.Number&&u[0]!==e.Percentage&&u[0]!==e.Dimension)return n;if(Number.isInteger(u[4].value))return n;const r=Number(u[4].value.toFixed(t)).toString();return u[0]===e.Number?u[1]=r:u[0]===e.Percentage?u[1]=r+"%":u[0]===e.Dimension&&(u[1]=r+u[4].unit),n}function patchCalcResult(e,n){return patchMinusZero(patchPrecision(patchInfinity(patchNaN(e)),n))}const L=new Map([["abs",abs],["calc",calc],["clamp",clamp],["cos",cos],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign],["sin",sin],["tan",tan]]);function convert(e,n){const t=tokenizeGlobals(null==n?void 0:n.globals),a=u({css:e}),i=[];for(;!a.endOfFile();)i.push(a.nextToken());i.push(a.nextToken());const o=f(i,{});for(let e=0;e<o.length;e++){const u=o[e];for(let e=0;e<u.length;e++){const r=u[e];if(c(r)){const a=L.get(r.getName().toLowerCase());if(a){const i=patchCalcResult(solve(a(r,t)),null==n?void 0:n.precision);if(-1!==i){u.splice(e,1,i);continue}}}(s(r)||c(r))&&r.walk(((e,u)=>{if("number"!=typeof u)return;const r=e.node;if(c(r)){const a=L.get(r.getName().toLowerCase());if(!a)return;const i=patchCalcResult(solve(a(r,t)),null==n?void 0:n.precision);if(-1!==i)return void e.parent.value.splice(u,1,i)}}))}}return o.map((e=>e.map((e=>r(...e.tokens()))).join(""))).join(",")}export{convert};
