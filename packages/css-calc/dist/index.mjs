import{TokenType as e,NumberType as n,isToken as t,tokenizer as i,stringify as u}from"@csstools/css-tokenizer";import{isTokenNode as r,TokenNode as a,isCommentNode as o,isWhitespaceNode as l,isSimpleBlockNode as s,isFunctionNode as c,FunctionNode as v,WhitespaceNode as m,parseCommaSeparatedListOfComponentValues as p}from"@csstools/css-parser-algorithms";function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){if(-1===e)return-1;const n=[];for(let t=0;t<e.inputs.length;t++){const i=e.inputs[t];if(r(i)){n.push(i);continue}const u=solve(i);if(-1===u)return-1;n.push(u)}return e.operation(n)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.Number||t[0]===e.Dimension||t[0]===e.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const i=t[0].value,u=t[1].value;if(i[0]===e.Number&&u[0]===e.Number){const t=i[4].value*u[4].value;return new a([e.Number,t.toString(),i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(i[0]===e.Percentage&&u[0]===e.Number){const n=i[4].value*u[4].value;return new a([e.Percentage,n.toString()+"%",i[2],u[3],{value:n}])}if(i[0]===e.Number&&u[0]===e.Percentage){const n=i[4].value*u[4].value;return new a([e.Percentage,n.toString()+"%",i[2],u[3],{value:n}])}if(i[0]===e.Dimension&&u[0]===e.Number){const t=i[4].value*u[4].value;return new a([e.Dimension,t.toString()+i[4].unit,i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:i[4].unit}])}if(i[0]===e.Number&&u[0]===e.Dimension){const t=i[4].value*u[4].value;return new a([e.Dimension,t.toString()+u[4].unit,i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:u[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const i=t[0].value,u=t[1].value;if(i[0]===e.Number&&u[0]===e.Number){const t=i[4].value/u[4].value;return new a([e.Number,t.toString(),i[2],u[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number}])}if(i[0]===e.Percentage&&u[0]===e.Number){const n=i[4].value/u[4].value;return new a([e.Percentage,n.toString()+"%",i[2],u[3],{value:n}])}if(i[0]===e.Dimension&&u[0]===e.Number){const t=i[4].value/u[4].value;return new a([e.Dimension,t.toString()+i[4].unit,i[2],u[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number,unit:i[4].unit}])}return-1}const g=new Map([["cm",e=>e],["mm",e=>10*e],["q",e=>40*e],["in",e=>e/2.54],["pc",e=>e/2.54*6],["pt",e=>e/2.54*72],["px",e=>e/2.54*96]]),f=new Map([["deg",e=>e],["grad",e=>e/.9],["rad",e=>e/180*Math.PI],["turn",e=>e/360]]),N=new Map([["deg",e=>.9*e],["grad",e=>e],["rad",e=>.9*e/180*Math.PI],["turn",e=>.9*e/360]]),b=new Map([["hz",e=>e],["khz",e=>e/1e3]]),w=new Map([["cm",e=>2.54*e],["mm",e=>25.4*e],["q",e=>25.4*e*4],["in",e=>e],["pc",e=>6*e],["pt",e=>72*e],["px",e=>96*e]]),h=new Map([["hz",e=>1e3*e],["khz",e=>e]]),I=new Map([["cm",e=>e/10],["mm",e=>e],["q",e=>4*e],["in",e=>e/25.4],["pc",e=>e/25.4*6],["pt",e=>e/25.4*72],["px",e=>e/25.4*96]]),d=new Map([["ms",e=>e],["s",e=>e/1e3]]),y=new Map([["cm",e=>e/6*2.54],["mm",e=>e/6*25.4],["q",e=>e/6*25.4*4],["in",e=>e/6],["pc",e=>e],["pt",e=>e/6*72],["px",e=>e/6*96]]),P=new Map([["cm",e=>e/72*2.54],["mm",e=>e/72*25.4],["q",e=>e/72*25.4*4],["in",e=>e/72],["pc",e=>e/72*6],["pt",e=>e],["px",e=>e/72*96]]),C=new Map([["cm",e=>e/96*2.54],["mm",e=>e/96*25.4],["q",e=>e/96*25.4*4],["in",e=>e/96],["pc",e=>e/96*6],["pt",e=>e/96*72],["px",e=>e]]),D=new Map([["cm",e=>e/4/10],["mm",e=>e/4],["q",e=>e],["in",e=>e/4/25.4],["pc",e=>e/4/25.4*6],["pt",e=>e/4/25.4*72],["px",e=>e/4/25.4*96]]),M=new Map([["deg",e=>180*e/Math.PI],["grad",e=>180*e/Math.PI/.9],["rad",e=>e],["turn",e=>180*e/Math.PI/360]]),S=new Map([["ms",e=>1e3*e],["s",e=>e]]),F=new Map([["deg",e=>360*e],["grad",e=>360*e/.9],["rad",e=>360*e/180*Math.PI],["turn",e=>e]]),k=new Map([["cm",g],["mm",I],["q",D],["in",w],["pc",y],["pt",P],["px",C],["ms",d],["s",S],["deg",f],["grad",N],["rad",M],["turn",F],["hz",b],["khz",h]]);function convertUnit(t,i){if(t[0]!==e.Dimension)return i;if(i[0]!==e.Dimension)return i;const u=t[4].unit.toLowerCase(),r=i[4].unit.toLowerCase();if(u===r)return i;const a=k.get(r);if(!a)return i;const o=a.get(u);if(!o)return i;const l=o(i[4].value);return[e.Dimension,l.toString()+t[4].unit,i[2],i[3],{value:l,unit:t[4].unit,type:Number.isInteger(l)?n.Integer:n.Number}]}function addition(t){if(2!==t.length)return-1;const i=t[0].value;let u=t[1].value;if(i[0]===e.Number&&u[0]===e.Number){const t=i[4].value+u[4].value;return new a([e.Number,t.toString(),i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(i[0]===e.Percentage&&u[0]===e.Percentage){const n=i[4].value+u[4].value;return new a([e.Percentage,n.toString()+"%",i[2],u[3],{value:n}])}if(i[0]===e.Dimension&&u[0]===e.Dimension&&(u=convertUnit(i,u),i[4].unit.toLowerCase()===u[4].unit.toLowerCase())){const t=i[4].value+u[4].value;return new a([e.Dimension,t.toString()+i[4].unit,i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:i[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const i=t[0].value;let u=t[1].value;if(i[0]===e.Number&&u[0]===e.Number){const t=i[4].value-u[4].value;return new a([e.Number,t.toString(),i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(i[0]===e.Percentage&&u[0]===e.Percentage){const n=i[4].value-u[4].value;return new a([e.Percentage,n.toString()+"%",i[2],u[3],{value:n}])}if(i[0]===e.Dimension&&u[0]===e.Dimension&&(u=convertUnit(i,u),i[4].unit.toLowerCase()===u[4].unit.toLowerCase())){const t=i[4].value-u[4].value;return new a([e.Dimension,t.toString()+i[4].unit,i[2],u[3],{value:t,type:i[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:i[4].unit}])}return-1}function solveMin(t,i){const u=i[0];if(!u||!r(u))return-1;if(1!==new Set(i.map((e=>e.type))).size)return-1;const o=i[0].value;if(o[0]!==e.Dimension&&o[0]!==e.Number&&o[0]!==e.Percentage)return-1;if(1!==new Set(i.map((e=>e.value[0]))).size)return-1;const l=i.map((e=>convertUnit(o,e.value)));if(1!==new Set(l.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const s=l.map((e=>e[4].value)),c=Math.min(...s),v=t.tokens();return o[0]===e.Dimension?{inputs:[new a([e.Dimension,c.toString()+o[4].unit,v[0][2],v[v.length-1][3],{value:c,type:Number.isInteger(c)?n.Integer:n.Number,unit:o[4].unit}])],operation:unary}:o[0]===e.Percentage?{inputs:[new a([e.Percentage,c.toString()+"%",v[0][2],v[v.length-1][3],{value:c}])],operation:unary}:{inputs:[new a([e.Number,c.toString(),v[0][2],v[v.length-1][3],{value:c,type:Number.isInteger(c)?n.Integer:n.Number}])],operation:unary}}function solveMax(t,i){const u=i[0];if(!u||!r(u))return-1;if(1!==new Set(i.map((e=>e.type))).size)return-1;const o=i[0].value;if(o[0]!==e.Dimension&&o[0]!==e.Number&&o[0]!==e.Percentage)return-1;if(1!==new Set(i.map((e=>e.value[0]))).size)return-1;const l=i.map((e=>convertUnit(o,e.value)));if(1!==new Set(l.map((e=>(e[4].unit??"").toLowerCase()))).size)return-1;const s=l.map((e=>e[4].value)),c=Math.max(...s),v=t.tokens();return o[0]===e.Dimension?{inputs:[new a([e.Dimension,c.toString()+o[4].unit,v[0][2],v[v.length-1][3],{value:c,type:Number.isInteger(c)?n.Integer:n.Number,unit:o[4].unit}])],operation:unary}:o[0]===e.Percentage?{inputs:[new a([e.Percentage,c.toString()+"%",v[0][2],v[v.length-1][3],{value:c}])],operation:unary}:{inputs:[new a([e.Number,c.toString(),v[0][2],v[v.length-1][3],{value:c,type:Number.isInteger(c)?n.Integer:n.Number}])],operation:unary}}function solveClamp(t,i,u,o){if(!r(i)||!r(u)||!r(o))return-1;const l=i.value,s=convertUnit(l,u.value),c=convertUnit(l,o.value);if(l[0]!==e.Dimension&&l[0]!==e.Number&&l[0]!==e.Percentage)return-1;if(l[0]!==s[0])return-1;if(l[0]!==c[0])return-1;if(l[0]===e.Dimension){if(l[4].unit.toLowerCase()!==s[4].unit.toLowerCase())return-1;if(l[4].unit.toLowerCase()!==c[4].unit.toLowerCase())return-1}const v=Math.max(l[4].value,Math.min(s[4].value,c[4].value)),m=t.tokens();return l[0]===e.Dimension?{inputs:[new a([e.Dimension,v.toString()+l[4].unit,m[0][2],m[m.length-1][3],{value:v,type:Number.isInteger(v)?n.Integer:n.Number,unit:l[4].unit}])],operation:unary}:l[0]===e.Percentage?{inputs:[new a([e.Percentage,v.toString()+"%",m[0][2],m[m.length-1][3],{value:v}])],operation:unary}:{inputs:[new a([e.Number,v.toString(),m[0][2],m[m.length-1][3],{value:v,type:Number.isInteger(v)?n.Integer:n.Number}])],operation:unary}}function resolveGlobalsAndConstants(t,i){for(let u=0;u<t.length;u++){const o=t[u];if(!r(o))continue;const l=o.value;if(l[0]!==e.Ident)continue;const s=l[4].value.toLowerCase();switch(s){case"e":t.splice(u,1,new a([e.Number,Math.E.toString(),l[2],l[3],{value:Math.E,type:n.Number}]));break;case"pi":t.splice(u,1,new a([e.Number,Math.PI.toString(),l[2],l[3],{value:Math.PI,type:n.Number}]));break;case"infinity":t.splice(u,1,new a([e.Number,"infinity",l[2],l[3],{value:1/0,type:n.Number}]));break;case"-infinity":t.splice(u,1,new a([e.Number,"-infinity",l[2],l[3],{value:-1/0,type:n.Number}]));break;case"nan":t.splice(u,1,new a([e.Number,"NaN",l[2],l[3],{value:Number.NaN,type:n.Number}]));break;default:if(i.has(s)){const e=i.get(s);t.splice(u,1,new a(e))}}}return t}function solveRound(t,i,u,r){const o=u.value;if(o[0]!==e.Dimension&&o[0]!==e.Number&&o[0]!==e.Percentage)return-1;const l=convertUnit(o,r.value);if(o[0]!==l[0])return-1;if(o[0]===e.Dimension&&o[4].unit!==l[4].unit)return-1;let s;if(0===l[4].value)s=Number.NaN;else if(Number.isFinite(o[4].value)||Number.isFinite(l[4].value))if(!Number.isFinite(o[4].value)&&Number.isFinite(l[4].value))s=o[4].value;else if(Number.isFinite(o[4].value)&&!Number.isFinite(l[4].value))switch(i){case"down":s=o[4].value<0?-1/0:Object.is(-0,0*o[4].value)?-0:0;break;case"up":s=o[4].value>0?1/0:Object.is(0,0*o[4].value)?0:-0;break;default:s=Object.is(0,0*o[4].value)?0:-0}else if(Number.isFinite(l[4].value))switch(i){case"down":s=Math.floor(o[4].value/l[4].value)*l[4].value;break;case"up":s=Math.ceil(o[4].value/l[4].value)*l[4].value;break;case"to-zero":s=Math.trunc(o[4].value/l[4].value)*l[4].value;break;default:{let e=Math.floor(o[4].value/l[4].value)*l[4].value,n=Math.ceil(o[4].value/l[4].value)*l[4].value;if(e>n){const t=e;e=n,n=t}const t=Math.abs(o[4].value-e),i=Math.abs(o[4].value-n);t===i&&(s=n),s=t<i?e:n;break}}else s=o[4].value;else s=Number.NaN;const c=t.tokens();return o[0]===e.Dimension?{inputs:[new a([e.Dimension,s.toString()+o[4].unit,c[0][2],c[c.length-1][3],{value:s,type:Number.isInteger(s)?n.Integer:n.Number,unit:o[4].unit}])],operation:unary}:o[0]===e.Percentage?{inputs:[new a([e.Percentage,s.toString()+"%",c[0][2],c[c.length-1][3],{value:s}])],operation:unary}:{inputs:[new a([e.Number,s.toString(),c[0][2],c[c.length-1][3],{value:s,type:Number.isInteger(s)?n.Integer:n.Number}])],operation:unary}}function solveMod(t,i,u){const r=i.value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;const o=convertUnit(r,u.value);if(r[0]!==o[0])return-1;if(r[0]===e.Dimension&&r[4].unit!==o[4].unit)return-1;let l;l=0===o[4].value?Number.NaN:Number.isFinite(r[4].value)&&(Number.isFinite(o[4].value)||(o[4].value!==Number.POSITIVE_INFINITY||r[4].value!==Number.NEGATIVE_INFINITY&&!Object.is(0*r[4].value,-0))&&(o[4].value!==Number.NEGATIVE_INFINITY||r[4].value!==Number.POSITIVE_INFINITY&&!Object.is(0*r[4].value,0)))?Number.isFinite(o[4].value)?(r[4].value%o[4].value+o[4].value)%o[4].value:r[4].value:Number.NaN;const s=t.tokens();return r[0]===e.Dimension?{inputs:[new a([e.Dimension,l.toString()+r[4].unit,s[0][2],s[s.length-1][3],{value:l,type:Number.isInteger(l)?n.Integer:n.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.Percentage?{inputs:[new a([e.Percentage,l.toString()+"%",s[0][2],s[s.length-1][3],{value:l}])],operation:unary}:{inputs:[new a([e.Number,l.toString(),s[0][2],s[s.length-1][3],{value:l,type:Number.isInteger(l)?n.Integer:n.Number}])],operation:unary}}function solveRem(t,i,u){const r=i.value;if(r[0]!==e.Dimension&&r[0]!==e.Number&&r[0]!==e.Percentage)return-1;const o=convertUnit(r,u.value);if(r[0]!==o[0])return-1;if(r[0]===e.Dimension&&r[4].unit!==o[4].unit)return-1;let l;l=0===o[4].value?Number.NaN:Number.isFinite(r[4].value)?Number.isFinite(o[4].value)?r[4].value%o[4].value:r[4].value:Number.NaN;const s=t.tokens();return r[0]===e.Dimension?{inputs:[new a([e.Dimension,l.toString()+r[4].unit,s[0][2],s[s.length-1][3],{value:l,type:Number.isInteger(l)?n.Integer:n.Number,unit:r[4].unit}])],operation:unary}:r[0]===e.Percentage?{inputs:[new a([e.Percentage,l.toString()+"%",s[0][2],s[s.length-1][3],{value:l}])],operation:unary}:{inputs:[new a([e.Number,l.toString(),s[0][2],s[s.length-1][3],{value:l,type:Number.isInteger(l)?n.Integer:n.Number}])],operation:unary}}function solveAbs(t,i){const u=i.value;if(u[0]!==e.Dimension&&u[0]!==e.Number&&u[0]!==e.Percentage)return-1;const r=Math.abs(u[4].value),o=t.tokens();return u[0]===e.Dimension?{inputs:[new a([e.Dimension,r.toString()+u[4].unit,o[0][2],o[o.length-1][3],{value:r,type:Number.isInteger(r)?n.Integer:n.Number,unit:u[4].unit}])],operation:unary}:u[0]===e.Percentage?{inputs:[new a([e.Percentage,r.toString()+"%",o[0][2],o[o.length-1][3],{value:r}])],operation:unary}:{inputs:[new a([e.Number,r.toString(),o[0][2],o[o.length-1][3],{value:r,type:Number.isInteger(r)?n.Integer:n.Number}])],operation:unary}}function solveSign(t,i){const u=i.value;if(u[0]!==e.Dimension&&u[0]!==e.Number&&u[0]!==e.Percentage)return-1;const r=Math.sign(u[4].value),o=t.tokens();return{inputs:[new a([e.Number,r.toString(),o[0][2],o[o.length-1][3],{value:r,type:Number.isInteger(r)?n.Integer:n.Number}])],operation:unary}}const x=new Map([["abs",abs],["calc",calc],["clamp",clamp],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign]]);function calc(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t);if(1===i.length&&r(i[0]))return{inputs:[i[0]],operation:unary};let u=0;for(;u<i.length;){const n=i[u];if(s(n)&&n.startToken[0]===e.OpenParen){const e=calc(n,t);if(-1===e)return-1;i.splice(u,1,e)}else if(c(n)){const e=x.get(n.getName().toLowerCase());if(!e)return-1;{const r=e(n,t);if(-1===r)return-1;i.splice(u,1,r)}}else u++}if(u=0,1===i.length&&isCalculation(i[0]))return i[0];for(;u<i.length;){const n=i[u];if(!n||!r(n)&&!isCalculation(n)){u++;continue}const t=i[u+1];if(!t||!r(t)){u++;continue}const a=t.value;if(a[0]!==e.Delim||"*"!==a[4].value&&"/"!==a[4].value){u++;continue}const o=i[u+2];if(!o||!r(o)&&!isCalculation(o))return-1;"*"!==a[4].value?"/"!==a[4].value?u++:i.splice(u,3,{inputs:[n,o],operation:division}):i.splice(u,3,{inputs:[n,o],operation:multiplication})}if(u=0,1===i.length&&isCalculation(i[0]))return i[0];for(;u<i.length;){const n=i[u];if(!n||!r(n)&&!isCalculation(n)){u++;continue}const t=i[u+1];if(!t||!r(t)){u++;continue}const a=t.value;if(a[0]!==e.Delim||"+"!==a[4].value&&"-"!==a[4].value){u++;continue}const o=i[u+2];if(!o||!r(o)&&!isCalculation(o))return-1;"+"!==a[4].value?"-"!==a[4].value?u++:i.splice(u,3,{inputs:[n,o],operation:subtraction}):i.splice(u,3,{inputs:[n,o],operation:addition})}return 1===i.length&&isCalculation(i[0])?i[0]:-1}function clamp(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=[],a=[],s=[];{let n=u;for(let t=0;t<i.length;t++){const o=i[t];if(r(o)&&o.value[0]===e.Comma){if(n===s)return-1;if(n===a){n=s;continue}if(n===u){n=a;continue}return-1}n.push(o)}}const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));if(-1===c)return-1;const m=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],a),t));if(-1===m)return-1;const p=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],s),t));return-1===p?-1:solveClamp(n,c,m,p)}function max(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=[];{const n=[];let a=[];for(let t=0;t<i.length;t++){const u=i[t];r(u)&&u.value[0]===e.Comma?(n.push(a),a=[]):a.push(u)}n.push(a);for(let i=0;i<n.length;i++){if(0===n[i].length)return-1;const r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[i]),t));if(-1===r)return-1;u.push(r)}}return solveMax(n,u)}function min(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=[];{const n=[];let a=[];for(let t=0;t<i.length;t++){const u=i[t];r(u)&&u.value[0]===e.Comma?(n.push(a),a=[]):a.push(u)}n.push(a);for(let i=0;i<n.length;i++){if(0===n[i].length)return-1;const r=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],n[i]),t));if(-1===r)return-1;u.push(r)}}return solveMin(n,u)}const L=new Set(["nearest","up","down","to-zero"]);function round(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t);let u="";const a=[],s=[];{let n=a;for(let t=0;t<i.length;t++){const o=i[t];if(!u&&0===a.length&&0===s.length&&r(o)&&o.value[0]===e.Ident){const e=o.value;if(L.has(e[4].value.toLowerCase())){u=e[4].value.toLowerCase();continue}}if(r(o)&&o.value[0]===e.Comma){if(n===s)return-1;if(n===a&&u&&0===a.length)continue;if(n===a){n=s;continue}return-1}n.push(o)}}const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],a),t));if(-1===c)return-1;const m=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],s),t));return-1===m?-1:(u||(u="nearest"),solveRound(n,u,c,m))}function mod(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=[],a=[];{let n=u;for(let t=0;t<i.length;t++){const o=i[t];if(r(o)&&o.value[0]===e.Comma){if(n===a)return-1;if(n===u){n=a;continue}return-1}n.push(o)}}const s=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));if(-1===s)return-1;const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],a),t));return-1===c?-1:solveMod(n,s,c)}function rem(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=[],a=[];{let n=u;for(let t=0;t<i.length;t++){const o=i[t];if(r(o)&&o.value[0]===e.Comma){if(n===a)return-1;if(n===u){n=a;continue}return-1}n.push(o)}}const s=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],u),t));if(-1===s)return-1;const c=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],a),t));return-1===c?-1:solveRem(n,s,c)}function abs(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveAbs(n,u)}function sign(n,t){const i=resolveGlobalsAndConstants([...n.value.filter((e=>!o(e)&&!l(e)))],t),u=solve(calc(new v([e.Function,"calc(",-1,-1,{value:"calc"}],[e.CloseParen,")",-1,-1,void 0],i),t));return-1===u?-1:solveSign(n,u)}function tokenizeGlobals(n){const u=new Map;if(!n)return u;for(const[r,a]of n)if(t(a))u.set(r,a);else if("string"!=typeof a);else{const n=i({css:a}),t=n.nextToken();if(n.nextToken(),!n.endOfFile())continue;if(t[0]!==e.Number&&t[0]!==e.Dimension&&t[0]!==e.Percentage)continue;u.set(r,t)}return u}function patchNaN(t){if(-1===t)return-1;if(c(t))return t;const i=t.value;return i[0]!==e.Number&&i[0]!==e.Percentage&&i[0]!==e.Dimension?t:Number.isNaN(i[4].value)?i[0]===e.Number?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,"NaN",i[2],i[3],{value:"NaN"}])]):i[0]===e.Dimension?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,"NaN",i[2],i[3],{value:"NaN"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Delim,"*",i[2],i[3],{value:"*"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Dimension,"1"+i[4].unit,i[2],i[3],{value:1,type:n.Integer,unit:i[4].unit}])]):i[0]===e.Percentage?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,"NaN",i[2],i[3],{value:"NaN"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Delim,"*",i[2],i[3],{value:"*"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Percentage,"1%",i[2],i[3],{value:1}])]):-1:t}function patchInfinity(t){if(-1===t)return-1;if(c(t))return t;const i=t.value;if(i[0]!==e.Number&&i[0]!==e.Percentage&&i[0]!==e.Dimension)return t;if(Number.isFinite(i[4].value))return t;let u="";return Number.NEGATIVE_INFINITY===i[4].value&&(u="-"),i[0]===e.Number?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,u+"infinity",i[2],i[3],{value:u+"infinity"}])]):i[0]===e.Dimension?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,u+"infinity",i[2],i[3],{value:u+"infinity"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Delim,"*",i[2],i[3],{value:"*"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Dimension,"1"+i[4].unit,i[2],i[3],{value:1,type:n.Integer,unit:i[4].unit}])]):i[0]===e.Percentage?new v([e.Function,"calc(",i[2],i[3],{value:"calc"}],[e.CloseParen,")",i[2],i[3],void 0],[new a([e.Ident,u+"infinity",i[2],i[3],{value:u+"infinity"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Delim,"*",i[2],i[3],{value:"*"}]),new m([[e.Whitespace," ",i[2],i[3],void 0]]),new a([e.Percentage,"1%",i[2],i[3],{value:1}])]):-1}function patchMinusZero(n){if(-1===n)return-1;if(c(n))return n;const t=n.value;return t[0]!==e.Number&&t[0]!==e.Percentage&&t[0]!==e.Dimension?n:Object.is(-0,t[4].value)?("-0"===t[1]||(t[1]="-0"),n):n}function patchCalcResult(e){return patchMinusZero(patchInfinity(patchNaN(e)))}const z=new Map([["abs",abs],["calc",calc],["clamp",clamp],["max",max],["min",min],["mod",mod],["rem",rem],["round",round],["sign",sign]]);function convert(e,n){const t=tokenizeGlobals(n),r=i({css:e}),a=[];for(;!r.endOfFile();)a.push(r.nextToken());a.push(r.nextToken());const o=p(a,{});for(let e=0;e<o.length;e++){const n=o[e];for(let e=0;e<n.length;e++){const i=n[e];if(c(i)){const u=z.get(i.getName().toLowerCase());if(u){const r=patchCalcResult(solve(u(i,t)));if(-1!==r){n.splice(e,1,r);continue}}}(s(i)||c(i))&&i.walk(((e,n)=>{if("number"!=typeof n)return;const i=e.node;if(c(i)){const u=z.get(i.getName().toLowerCase());if(!u)return;const r=patchCalcResult(solve(u(i,t)));if(-1!==r)return void e.parent.value.splice(n,1,r)}}))}}return o.map((e=>e.map((e=>u(...e.tokens()))).join(""))).join(",")}export{convert};
