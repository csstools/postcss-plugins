import{TokenType as e,NumberType as n,tokenizer as t,stringify as r}from"@csstools/css-tokenizer";import{isTokenNode as u,TokenNode as i,parseCommaSeparatedListOfComponentValues as o,isFunctionNode as a,isSimpleBlockNode as l,isCommentNode as s,isWhitespaceNode as c}from"@csstools/css-parser-algorithms";function isCalculation(e){return"inputs"in e&&Array.isArray(e.inputs)&&"operation"in e}function solve(e){const n=[];for(let t=0;t<e.inputs.length;t++){const r=e.inputs[t];if(u(r)){n.push(r);continue}const i=solve(r);if(-1===i)return-1;n.push(i)}return e.operation(n)}function unary(n){if(1!==n.length)return-1;const t=n[0].value;return t[0]===e.Number||t[0]===e.Dimension||t[0]===e.Percentage?n[0]:-1}function multiplication(t){if(2!==t.length)return-1;const r=t[0].value,u=t[1].value;if(r[0]===e.Number&&u[0]===e.Number){const t=r[4].value*u[4].value;return new i([e.Number,t.toString(),r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&u[0]===e.Number){const n=r[4].value*u[4].value;return new i([e.Percentage,n.toString()+"%",r[2],u[3],{value:n}])}if(r[0]===e.Number&&u[0]===e.Percentage){const n=r[4].value*u[4].value;return new i([e.Percentage,n.toString()+"%",r[2],u[3],{value:n}])}if(r[0]===e.Dimension&&u[0]===e.Number){const t=r[4].value*u[4].value;return new i([e.Dimension,t.toString()+r[4].unit,r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}if(r[0]===e.Number&&u[0]===e.Dimension){const t=r[4].value*u[4].value;return new i([e.Dimension,t.toString()+u[4].unit,r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:u[4].unit}])}return-1}function division(t){if(2!==t.length)return-1;const r=t[0].value,u=t[1].value;if(r[0]===e.Number&&u[0]===e.Number){const t=r[4].value/u[4].value;return NaN_Token(t,r,u)??new i([e.Number,t.toString(),r[2],u[3],{value:t,type:Number.isInteger(t)?n.Integer:n.Number}])}if(r[0]===e.Percentage&&u[0]===e.Number){const n=r[4].value/u[4].value;return NaN_Token(n,r,u)??new i([e.Percentage,n.toString()+"%",r[2],u[3],{value:n}])}if(r[0]===e.Dimension&&u[0]===e.Number){const t=r[4].value/u[4].value;return NaN_Token(t,r,u)??new i([e.Dimension,t.toString()+r[4].unit,r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function NaN_Token(n,t,r){if(Number.isNaN(n))return new i([e.Ident,"NaN",t[2],r[3],{value:"NaN"}])}function addition(t){if(2!==t.length)return-1;const r=t[0].value,u=t[1].value;if(r[0]===e.Number&&u[0]===e.Number){const t=r[4].value+u[4].value;return new i([e.Number,t.toString(),r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&u[0]===e.Percentage){const n=r[4].value+u[4].value;return new i([e.Percentage,n.toString()+"%",r[2],u[3],{value:n}])}if(r[0]===e.Dimension&&u[0]===e.Dimension&&r[4].unit.toLowerCase()===u[4].unit.toLowerCase()){const t=r[4].value+u[4].value;return new i([e.Dimension,t.toString()+r[4].unit,r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function subtraction(t){if(2!==t.length)return-1;const r=t[0].value,u=t[1].value;if(r[0]===e.Number&&u[0]===e.Number){const t=r[4].value-u[4].value;return new i([e.Number,t.toString(),r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number}])}if(r[0]===e.Percentage&&u[0]===e.Percentage){const n=r[4].value-u[4].value;return new i([e.Percentage,n.toString()+"%",r[2],u[3],{value:n}])}if(r[0]===e.Dimension&&u[0]===e.Dimension&&r[4].unit.toLowerCase()===u[4].unit.toLowerCase()){const t=r[4].value-u[4].value;return new i([e.Dimension,t.toString()+r[4].unit,r[2],u[3],{value:t,type:r[4].type===n.Integer&&u[4].type===n.Integer?n.Integer:n.Number,unit:r[4].unit}])}return-1}function convert(e,n){const u=t({css:e}),i=[];for(;!u.endOfFile();)i.push(u.nextToken());i.push(u.nextToken());const s=o(i,{onParseError:e=>{throw e}});for(let t=0;t<s.length;t++){const r=s[t];for(let t=0;t<r.length;t++){const u=r[t];if(a(u)&&"calc"===u.getName().toLowerCase()){const i=calcHandler(u,n??new Map);if(-1===i)return e;const o=solve(i);if(-1===o)return e;r.splice(t,1,o)}else(l(u)||a(u))&&u.walk(((e,t)=>{if("number"!=typeof t)return;const r=e.node;if(!a(r)||"calc"!==r.getName().toLowerCase())return;const u=calcHandler(r,n??new Map);if(-1===u)return;const i=solve(u);-1!==i&&e.parent.value.splice(t,1,i)}))}}return s.map((e=>e.map((e=>r(...e.tokens()))).join(""))).join(",")}function calcHandler(t,r){const o=[...t.value.filter((e=>!s(e)&&!c(e)))];for(let t=0;t<o.length;t++){const a=o[t];if(!u(a))continue;const l=a.value;if(l[0]!==e.Ident)continue;const s=l[4].value.toLowerCase();switch(s){case"e":o.splice(t,1,new i([e.Number,Math.E.toString(),l[2],l[3],{value:Math.E,type:n.Number}]));break;case"pi":o.splice(t,1,new i([e.Number,Math.PI.toString(),l[2],l[3],{value:Math.PI,type:n.Number}]));break;default:if(r.has(s)){const u=r.get(s);o.splice(t,1,new i([e.Number,u.toString(),l[2],l[3],{value:u,type:n.Number}]))}}}if(1===o.length&&u(o[0]))return{inputs:[o[0]],operation:unary};let g=0;for(;g<o.length;){const n=o[g];if(l(n)&&n.startToken[0]===e.OpenParen){const e=calcHandler(n,r);if(-1===e)return-1;o.splice(g,1,e)}else if(a(n))switch(n.getName().toLowerCase()){case"calc":{const e=calcHandler(n,r);if(-1===e)return-1;o.splice(g,1,e);break}default:return-1}else g++}if(g=0,1===o.length&&isCalculation(o[0]))return o[0];for(;g<o.length;){const n=o[g];if(!n||!u(n)&&!isCalculation(n)){g++;continue}const t=o[g+1];if(!t||!u(t)){g++;continue}const r=t.value;if(r[0]!==e.Delim||"*"!==r[4].value&&"/"!==r[4].value){g++;continue}const i=o[g+2];if(!i||!u(i)&&!isCalculation(i))return-1;"*"!==r[4].value?"/"!==r[4].value?g++:o.splice(g,3,{inputs:[n,i],operation:division}):o.splice(g,3,{inputs:[n,i],operation:multiplication})}if(g=0,1===o.length&&isCalculation(o[0]))return o[0];for(;g<o.length;){const n=o[g];if(!n||!u(n)&&!isCalculation(n)){g++;continue}const t=o[g+1];if(!t||!u(t)){g++;continue}const r=t.value;if(r[0]!==e.Delim||"+"!==r[4].value&&"-"!==r[4].value){g++;continue}const i=o[g+2];if(!i||!u(i)&&!isCalculation(i))return-1;"+"!==r[4].value?"-"!==r[4].value?g++:o.splice(g,3,{inputs:[n,i],operation:subtraction}):o.splice(g,3,{inputs:[n,i],operation:addition})}return 1===o.length&&isCalculation(o[0])?o[0]:-1}export{convert};
