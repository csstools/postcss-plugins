/* node:coverage disable */
import t from"fs/promises";import s from"path";import e from"postcss";import o from"postcss-8.4";import n from"postcss-html";import a from"node:assert/strict";import c from"node:test";const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});function reduceInformationInCssSyntaxError(t){process.env.DEBUG||(delete t.source,t.input&&delete t.input.source,delete t.postcssNode)}async function fileContentsOrEmptyString(s){try{return await t.readFile(s,"utf8")}catch(t){return""}}function postcssSyntax(t){if(t.postcssSyntaxHTML)return n()}function postcssSyntaxSupportsSourceMaps(t){return!t.postcssSyntaxHTML}function postcssTape(n,r){r=r??{},c("`postcss` flag is set on exported plugin creator",(()=>{a.strictEqual(n.postcss,!0)})),c("exported plugin creator is a function",(()=>{a.strictEqual(typeof n,"function")})),c("`postcssPlugin` is set on a plugin instance",(()=>{const t=n();a.ok(t.postcssPlugin),a.strictEqual(typeof t.postcssPlugin,"string")})),c("package.json",(async s=>{const e=await t.readFile("./package.json","utf-8"),o=JSON.parse(e);await s.test('includes "postcss-plugin" keyword',(()=>{a.ok(o.keywords),a.ok(o.keywords.includes("postcss-plugin"))})),await s.test('name starts with "postcss-"',{skip:r?.skipPackageNameCheck},(()=>{let t=o.name;if(t.startsWith("@")){t=o.name.split("/").slice(1).join("/")}a.ok(t.startsWith("postcss-"),`package name "${t}" does not start with "postcss-"`)})),await s.test("`postcss` is a peer dependency and not a direct dependency",{skip:"postcssTapeSelfTest"in n},(()=>{a.ok(o.peerDependencies),a.ok(Object.keys(Object(o.peerDependencies)).includes("postcss")),a.ok(!Object.keys(Object(o.dependencies)).includes("postcss"))}))}));const i=n().postcssPlugin;return async r=>{await c(i,(async c=>{for(const i in r)await c.test(i,(async c=>{const p=r[i];p.before&&await p.before();const l=s.join(".","test",i.split(":")[0]),u=s.join(".","test",i.replace(/:/g,"."));let d="css";p.postcssSyntaxHTML&&(d="html");const f=`${l}.${d}`;let m=`${u}.expect.${d}`,S=`${u}.result.${d}`;p.expect&&(m=s.join(".","test",p.expect)),p.result&&(S=s.join(".","test",p.result));const g=p.plugins??[n(p.options)],y=await fileContentsOrEmptyString(f),w=await fileContentsOrEmptyString(m);let x,k=!1;try{x=await e(g).process(y,{from:f,to:S,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1},syntax:postcssSyntax(p)})}catch(t){if(reduceInformationInCssSyntaxError(t),k=!0,p.exception&&p.exception.test(t.message))return;a.ifError(t)}a.notEqual(!k,p.exception,"expected an exception but got none");const h=x.css.toString();{const s=[t.writeFile(S,h,"utf8")];process.env.REWRITE_EXPECTS&&s.push(t.writeFile(m,h,"utf8")),await Promise.all(s)}a.ok(w,"Missing expected result file"),await c.test("has expected output",(()=>{a.strictEqual(h,w),a.deepStrictEqual(x.warnings().length,p.warnings??0,"Unexpected number warnings")})),await c.test("sourcemaps",{skip:!postcssSyntaxSupportsSourceMaps(p)},(async()=>{a.ok(!x.map.toJSON().sources.includes("<no source>"),'Sourcemap is broken. This is most likely a newly created PostCSS AST Node without a value for "source". See: https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes')})),p.after&&await p.after(),await c.test("output is parsable with PostCSS",(async()=>{const t=await fileContentsOrEmptyString(S),s=await e([noopPlugin()]).process(t,{from:S,to:S,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1},syntax:postcssSyntax(p)});a.deepStrictEqual(s.warnings(),[],"Unexpected warnings on second pass")})),await c.test("The oldest and current PostCSS version produce the same result",{skip:e([noopPlugin()]).version===o([noopPlugin()]).version},(async()=>{const t=await o(g).process(y,{from:f,to:S,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1}});a.strictEqual(t.css.toString(),h)}))}))}))}}noopPlugin.postcss=!0;const r={postcssPlugin:"declaration-cloner",Declaration(t){"to-clone"===t.prop&&t.cloneBefore({prop:"cloned"})}},i={postcssPlugin:"rule-cloner",prepare(){const t=new WeakSet;return{RuleExit(s){t.has(s)||"to-clone"===s.selector&&(t.add(s),s.cloneBefore({selector:"cloned"}))}}}},p={postcssPlugin:"at-rule-cloner",prepare(){const t=new WeakSet;return{AtRuleExit(s){if(!t.has(s))return"to-clone"===s.params?(t.add(s),void s.cloneBefore({params:"cloned"})):"to-clone"===s.name?(t.add(s),void s.cloneBefore({name:"cloned"})):void 0}}}};export{p as atRuleClonerPlugin,r as declarationClonerPlugin,postcssTape,i as ruleClonerPlugin};
/* node:coverage enable */
