/* node:coverage disable */
"use strict";var e=require("node:assert/strict"),t=require("fs/promises"),s=require("path"),n=require("postcss"),o=require("postcss-8.4"),i=require("node:test");const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});async function fileContentsOrEmptyString(e){try{return await t.readFile(e,"utf8")}catch(e){return""}}function reduceInformationInCssSyntaxError(e){process.env.DEBUG||(delete e.source,e.input&&delete e.input.source,delete e.postcssNode)}noopPlugin.postcss=!0;const r={postcssPlugin:"declaration-cloner",Declaration(e){"to-clone"===e.prop&&e.cloneBefore({prop:"cloned"})}},a={postcssPlugin:"rule-cloner",prepare(){const e=new WeakSet;return{RuleExit(t){e.has(t)||"to-clone"===t.selector&&(e.add(t),t.cloneBefore({selector:"cloned"}))}}}},c={postcssPlugin:"at-rule-cloner",prepare(){const e=new WeakSet;return{AtRuleExit(t){if(!e.has(t))return"to-clone"===t.params?(e.add(t),void t.cloneBefore({params:"cloned"})):"to-clone"===t.name?(e.add(t),void t.cloneBefore({name:"cloned"})):void 0}}}};exports.atRuleClonerPlugin=c,exports.declarationClonerPlugin=r,exports.postcssTape=function postcssTape(r,a){a=a??{},i("`postcss` flag is set on exported plugin creator",(()=>{e.strictEqual(r.postcss,!0)})),i("exported plugin creator is a function",(()=>{e.strictEqual(typeof r,"function")})),i("`postcssPlugin` is set on a plugin instance",(()=>{const t=r();e.ok(t.postcssPlugin),e.strictEqual(typeof t.postcssPlugin,"string")})),i("package.json",(async s=>{const n=await t.readFile("./package.json","utf-8"),o=JSON.parse(n);await s.test('includes "postcss-plugin" keyword',(()=>{e.ok(o.keywords),e.ok(o.keywords.includes("postcss-plugin"))})),await s.test('name starts with "postcss-"',{skip:a?.skipPackageNameCheck},(()=>{let t=o.name;if(t.startsWith("@")){t=o.name.split("/").slice(1).join("/")}e.ok(t.startsWith("postcss-"),`package name "${t}" does not start with "postcss-"`)})),await s.test("`postcss` is a peer dependency and not a direct dependency",{skip:"postcssTapeSelfTest"in r},(()=>{e.ok(o.peerDependencies),e.ok(Object.keys(Object(o.peerDependencies)).includes("postcss")),e.ok(!Object.keys(Object(o.dependencies)).includes("postcss"))}))}));const c=r().postcssPlugin;return async a=>{await i(c,(async i=>{for(const c in a)await i.test(c,(async i=>{const p=a[c];p.before&&await p.before();const l=s.join(".","test",...c.split(":")[0].split(s.posix.sep)),u=s.join(".","test",...c.replace(/:/g,".").split(s.posix.sep)),d="css";let g=`${l}.${d}`,f=`${u}.expect.${d}`,w=`${u}.result.${d}`;p.source&&(g=s.join(".","test",p.source)),p.expect&&(f=s.join(".","test",p.expect)),p.result&&(w=s.join(".","test",p.result));const m=p.plugins??[r(p.options)],k=await fileContentsOrEmptyString(g),y=await fileContentsOrEmptyString(f);let S,x=!1;try{S=await n(m).process(k,{from:g,to:w,map:{inline:!1,annotation:!1}})}catch(t){if(reduceInformationInCssSyntaxError(t),x=!0,p.exception&&p.exception.test(t.message))return;e.ifError(t)}e.notEqual(!x,p.exception,"expected an exception but got none");const E=S.css.toString();{const e=[t.writeFile(w,E,"utf8")];process.env.REWRITE_EXPECTS&&e.push(t.writeFile(f,E,"utf8")),await Promise.all(e)}e.ok(y,`Missing expect file: "${f}"`),await i.test("has expected output",(()=>{e.strictEqual(E,y),e.deepStrictEqual(S.warnings().length,p.warnings??0,"Unexpected number warnings")})),await i.test("sourcemaps",(async()=>{e.ok(!S.map.toJSON().sources.includes("<no source>"),'Sourcemap is broken. This is most likely a newly created PostCSS AST Node without a value for "source". See: https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes')})),p.after&&await p.after(),await i.test("output is parsable with PostCSS",(async()=>{const t=await fileContentsOrEmptyString(w),s=await n([noopPlugin()]).process(t,{from:w,to:w,map:{inline:!1,annotation:!1}});e.deepStrictEqual(s.warnings(),[],"Unexpected warnings on second pass")})),await i.test("The oldest and current PostCSS version produce the same result",{skip:n([noopPlugin()]).version===o([noopPlugin()]).version},(async()=>{const t=await o(m).process(k,{from:g,to:w,map:{inline:!1,annotation:!1}});e.strictEqual(t.css.toString(),E)}))}))}))}},exports.ruleClonerPlugin=a;
/* node:coverage enable */
