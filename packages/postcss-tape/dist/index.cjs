"use strict";var e=require("fs"),n=require("path"),o=require("postcss"),t=require("postcss-8.4"),s=require("assert");const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});noopPlugin.postcss=!0;const r="----------------------------------------";function formatCSSAssertError(e,n,o,t=!1){let s="";if(s+=`\n${e}\n\n`,n.message&&(s+=`message :\n  ${n.message}\n\n`),n.options)try{s+=`options :\n${JSON.stringify(n.options,null,2)}\n\n`}catch(e){}return s+=`output changed :\n${prettyDiff(o.message)}\n`,t||(s+="\n"+r),s}function formatWarningsAssertError(e,n,o,t,s=!1){let c="";if(c+=`\n${e}\n\n`,n.message&&(c+=`message :\n  ${n.message}\n\n`),n.options)try{c+=`options :\n${JSON.stringify(n.options,null,2)}\n\n`}catch(e){}return c+=`unexpected or missing warnings :\n+ actual ${o.length}\n- expected ${t}\n`,s||(o.forEach((e=>{c+=`\n[${e.plugin}]: ${e.text}`})),o.length&&(c+="\n"),c+="\n"+r),c}function prettyDiff(e){return e.replace(/[^\\](\\n)/gm,((e,n)=>e.replace(n," "))).replace(/(\\t)/gm,((e,n)=>e.replace(n," "))).replace(/\+$/gm,"").replace(/^Expected values to be strictly equal:\n/,"")}function formatGitHubActionAnnotation(e,o="error",t={}){let s="::"+o;const r=Object.keys(t).map((e=>{let o=String(t[e]);return"file"===e&&process.env.GITHUB_WORKSPACE&&(o=n.relative(process.env.GITHUB_WORKSPACE,n.resolve(o))),`${e}=${s=o,s.replace(/\r/g,"%0D").replace(/\n/g,"%0A").replace(/]/g,"%5D").replace(/;/g,"%3B")}`;var s})).join(",");return r&&(s+=` ${r}`),`${s}::${c=e||"",c.replace(/\r/g,"%0D").replace(/\n/g,"%0A")}`;var c}function reduceInformationInCssSyntaxError(e){process.env.DEBUG||(delete e.source,e.input&&delete e.input.source,delete e.postcssNode)}const c=process.env.GITHUB_ACTIONS&&"true"===process.env.ENABLE_ANNOTATIONS_FOR_NODE&&"true"===process.env.ENABLE_ANNOTATIONS_FOR_OS;const i={postcssPlugin:"declaration-cloner",Declaration(e){"to-clone"===e.prop&&e.cloneBefore({prop:"cloned"})}},a={postcssPlugin:"rule-cloner",prepare(){const e=new WeakSet;return{RuleExit(n){e.has(n)||"to-clone"===n.selector&&(e.add(n),n.cloneBefore({selector:"cloned"}))}}}},l={postcssPlugin:"at-rule-cloner",prepare(){const e=new WeakSet;return{AtRuleExit(n){if(!e.has(n))return"to-clone"===n.params?(e.add(n),void n.cloneBefore({params:"cloned"})):"to-clone"===n.name?(e.add(n),void n.cloneBefore({name:"cloned"})):void 0}}}};exports.atRuleClonerPlugin=l,exports.declarationClonerPlugin=i,exports.postcssTape=function postcssTape(i){let a=!1;{!0!==i.postcss&&(a=!0,c?console.log(formatGitHubActionAnnotation('postcss flag not set to "true" on exported plugin object',"error",{file:"./package.json",line:1,col:1})):console.error(`\npostcss flag not set to "true"\n\n${r}`));const n=i();n.postcssPlugin&&"string"==typeof n.postcssPlugin||(a=!0,c?console.log(formatGitHubActionAnnotation('plugin name not set via "postcssPlugin"',"error",{file:"./package.json",line:1,col:1})):console.error(`\nplugin name not set via "postcssPlugin"\n\n${r}`));const o=JSON.parse(e.readFileSync("./package.json","utf-8").toString());o.keywords&&o.keywords.includes("postcss-plugin")||(a=!0,c?console.log(formatGitHubActionAnnotation('package.json does not include "postcss-plugin" keyword',"error",{file:"./package.json",line:1,col:1})):console.error(`\npackage.json does not include "postcss-plugin" keyword\n\n${r}`));const t=["css-has-pseudo","css-blank-pseudo","css-prefers-color-scheme","@csstools/css-has-pseudo-experimental"].includes(o.name);let s=o.name;if(s.startsWith("@")){s=o.name.split("/").slice(1).join("/")}s.startsWith("postcss-")||t||(a=!0,c?console.log(formatGitHubActionAnnotation('plugin name in package.json does not start with "postcss-"',"error",{file:"./package.json",line:1,col:1})):console.error(`\nplugin name in package.json does not start with "postcss-"\n\n${r}`)),Object.keys(Object(o.dependencies)).includes("postcss")&&!("postcssTapeSelfTest"in i)&&(a=!0,c?console.log(formatGitHubActionAnnotation("postcss should only be a peer and/or dev dependency","error",{file:"./package.json",line:1,col:1})):console.error(`\npostcss should only be a peer and/or dev dependency\n\n${r}`))}return async l=>{const p=new Set;for(const u in l){const g=l[u];g.before&&await g.before();const f=n.join(".","test",u.split(":")[0]),d=n.join(".","test",u.replace(/:/g,".")),m="css",S=`${f}.${m}`;let A=`${d}.expect.${m}`,$=`${d}.result.${m}`;g.expect&&(A=n.join(".","test",g.expect)),g.result&&($=n.join(".","test",g.result));const w=g.plugins??[i(g.options)],y=e.readFileSync(S,"utf8");let h,b="";try{b=e.readFileSync(A,"utf8")}catch(e){a=!0,b=!1,c?console.log(formatGitHubActionAnnotation(`${u}\n\nmissing or broken "expect" file: "${n.parse(A).base}"`,"error",{file:S,line:1,col:1})):(p.add(u),console.error(`\n${u}\n\nmissing or broken "expect" file: "${n.parse(A).base}"\n\n${r}`))}let E=!1;try{h=await o(w).process(y,{from:S,to:$,map:{inline:!1,annotation:!1}})}catch(e){if(reduceInformationInCssSyntaxError(e),E=!0,g.exception&&g.exception.test(e.message))continue;throw e}!E&&g.exception&&(a=!0,c?console.log(formatGitHubActionAnnotation(`${u}\n\nexpected an exception but got none`,"error",{file:S,line:1,col:1})):(p.add(u),console.error(`\n${u}\n\nexpected an exception but got none\n\n${r}`)));const x=h.css.toString();if(e.writeFileSync($,x,"utf8"),process.env.REWRITE_EXPECTS&&e.writeFileSync(A,x,"utf8"),!1!==b){try{s.strict.strictEqual(x,b)}catch(e){a=!0,c?console.log(formatGitHubActionAnnotation(formatCSSAssertError(u,g,e,!0),"error",{file:A,line:1,col:1})):(p.add(u),console.error(formatCSSAssertError(u,g,e)))}try{if(h.map.toJSON().sources.includes("<no source>"))throw new Error("Sourcemap is broken")}catch(e){a=!0;const n='\nThis is most likely a newly created PostCSS AST Node without a value for "source".\nsee :\n- https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes\n- https://postcss.org/api/#node-source';c?console.log(formatGitHubActionAnnotation(`${u}\n\nbroken source map: ${JSON.stringify(h.map.toJSON().sources)}\n${n}`,"error",{file:S,line:1,col:1})):(p.add(u),console.error(`\n${u}\n\nbroken source map: ${JSON.stringify(h.map.toJSON().sources)}\n${n}\n\n${r}`))}g.after&&await g.after();try{const n=e.readFileSync($,"utf8");if((await o([noopPlugin()]).process(n,{from:$,to:$,map:{inline:!1,annotation:!1}})).warnings().length)throw new Error("Unexpected warnings on second pass")}catch(e){a=!0,c?console.log(formatGitHubActionAnnotation(`${u}\n\nresult was not parsable with PostCSS.`,"error",{file:A,line:1,col:1})):(p.add(u),console.error(`\n${u}\n\nresult was not parsable with PostCSS.\n\n${r}`))}if(o([noopPlugin()]).version!==t([noopPlugin()]).version){const e=await t(w).process(y,{from:S,to:$,map:{inline:!1,annotation:!1}});try{s.strict.strictEqual(e.css.toString(),x)}catch(e){reduceInformationInCssSyntaxError(e),a=!0,c?console.log(formatGitHubActionAnnotation("testing older PostCSS:\n"+formatCSSAssertError(u,g,e,!0),"error",{file:A,line:1,col:1})):(p.add(u),console.error("testing older PostCSS:\n"+formatCSSAssertError(u,g,e)))}}try{(h.warnings().length||g.warnings)&&s.strict.strictEqual(h.warnings().length,g.warnings)}catch(e){a=!0,c?console.log(formatGitHubActionAnnotation(formatWarningsAssertError(u,g,h.warnings(),g.warnings??0,!0),"error",{file:A,line:1,col:1})):(p.add(u),console.error(formatWarningsAssertError(u,g,h.warnings(),g.warnings??0)))}}}if(p.size){console.error("\nunexpected failures:");for(const e of p.values())console.error("  - "+e)}a&&process.exit(1),console.warn("pass "+i().postcssPlugin)}},exports.ruleClonerPlugin=a;
