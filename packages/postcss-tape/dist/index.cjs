/* node:coverage disable */
"use strict";var e=require("node:assert/strict"),t=require("node:fs/promises"),s=require("node:fs"),r=require("node:path"),o=require("postcss"),n=require("postcss-8.4"),i=require("node:test"),a=require("node:url");const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});async function fileContentsOrEmptyString(e){try{return await t.readFile(e,"utf8")}catch(e){return""}}function reduceInformationInCssSyntaxError(e){process.env.DEBUG||(delete e.source,e.input&&delete e.input.source,delete e.postcssNode)}noopPlugin.postcss=!0;const typeCheckerPlugin=()=>({postcssPlugin:"type-checker-plugin",OnceExit(e){e.walkAtRules((e=>{if("string"!=typeof e.params)throw e.error(`Params must be of type 'string', found '${typeof e.params}' instead`);if("string"!=typeof e.type)throw e.error(`Type must be of type 'string', found '${typeof e.type}' instead`);if("atrule"!==e.type)throw e.error(`Type must be 'atrule', found '${e.type}' instead`);if("string"!=typeof e.name)throw e.error(`Name must be of type 'string', found '${typeof e.name}' instead`);if(e.nodes&&!Array.isArray(e.nodes))throw e.error(`Nodes must be of type 'Array' when it is present, found '${typeof e.nodes}' instead`);if(!("parent"in e))throw e.error("AtRule must have a 'parent' property");if(!("first"in e))throw e.error("AtRule must have a 'first' property");if(!("last"in e))throw e.error("AtRule must have a 'last' property")})),e.walkRules((e=>{if("string"!=typeof e.selector)throw e.error(`Selector must be of type 'string', found '${typeof e.selector}' instead`);if("string"!=typeof e.type)throw e.error(`Type must be of type 'string', found '${typeof e.type}' instead`);if("rule"!==e.type)throw e.error(`Type must be 'rule', found '${e.type}' instead`);if(!Array.isArray(e.nodes))throw e.error(`Nodes must be of type 'Array', found '${typeof e.nodes}' instead`);if(!("parent"in e))throw e.error("Rule must have a 'parent' property");if(!("first"in e))throw e.error("Rule must have a 'first' property");if(!("last"in e))throw e.error("Rule must have a 'last' property")}))}});typeCheckerPlugin.postcss=!0;const p={postcssPlugin:"declaration-cloner",Declaration(e){"to-clone"===e.prop&&e.cloneBefore({prop:"cloned"})}},c={postcssPlugin:"rule-cloner",prepare(){const e=new WeakSet;return{RuleExit(t){e.has(t)||"to-clone"===t.selector&&(e.add(t),t.cloneBefore({selector:"cloned"}))}}}},u={postcssPlugin:"at-rule-cloner",prepare(){const e=new WeakSet;return{AtRuleExit(t){if(!e.has(t))return"to-clone"===t.params?(e.add(t),void t.cloneBefore({params:"cloned"})):"to-clone"===t.name?(e.add(t),void t.cloneBefore({name:"cloned"})):void 0}}}};class PackageDescriptionError extends Error{constructor(e,t){super(e),this.name="PackageDescriptionError",this.stack=`${this.name}: ${this.message}\n    at "${t}" (${a.pathToFileURL(r.resolve("package.json"))}:1:1)`}}class OutcomeError extends Error{constructor(e,t){super(e),this.name="OutcomeError",this.stack=`${this.name}: ${this.message}\n    at ${a.pathToFileURL(r.resolve(t))}:1:1`}}exports.atRuleClonerPlugin=u,exports.declarationClonerPlugin=p,exports.postcssTape=function postcssTape(a,p){p=p??{},i("`postcss` flag is set on exported plugin creator",(()=>{e.equal(a.postcss,!0)})),i("exported plugin creator is a function",(()=>{e.equal(typeof a,"function")})),i("`postcssPlugin` is set on a plugin instance",(()=>{const t=a();e.ok(t.postcssPlugin),e.equal(typeof t.postcssPlugin,"string")})),i("package.json",(async s=>{const r=await t.readFile("./package.json","utf-8"),o=JSON.parse(r);await s.test('includes "postcss-plugin" keyword',(()=>{e.ok(o.keywords?.includes("postcss-plugin"),new PackageDescriptionError('Missing "postcss-plugin" keyword in package.json',"keywords"))})),await s.test('name starts with "postcss-"',{skip:p?.skipPackageNameCheck},(()=>{let t=o.name;if(t.startsWith("@")){t=o.name.split("/").slice(1).join("/")}e.ok(t.startsWith("postcss-"),new PackageDescriptionError(`package name "${t}" does not start with "postcss-"`,"name"))})),await s.test("`postcss` is a peer dependency and not a direct dependency",{skip:"postcssTapeSelfTest"in a},(()=>{e.ok(Object.keys(Object(o.peerDependencies)).includes("postcss"),new PackageDescriptionError('"postcss" must be listed in "peerDependencies"',"peerDependencies")),e.ok(!Object.keys(Object(o.dependencies)).includes("postcss"),new PackageDescriptionError('"postcss" must not be listed in "dependencies"',"dependencies"))}))}));const c=a().postcssPlugin;return async p=>{await i(c,(async i=>{for(const c in p)await i.test(c,(async i=>{const u=p[c];u.before&&await u.before();const l=r.join(".","test",...c.split(":")[0].split(r.posix.sep)),d=r.join(".","test",...c.replace(/:/g,".").split(r.posix.sep)),f="css";let y=`${l}.${f}`,m=`${d}.expect.${f}`,g=`${d}.result.${f}`;u.source&&(y=r.join(".","test",u.source)),u.expect&&(m=r.join(".","test",u.expect)),u.result&&(g=r.join(".","test",u.result));const w=u.plugins??[a(u.options)];w.push(typeCheckerPlugin());const h=await fileContentsOrEmptyString(y),k=await fileContentsOrEmptyString(m);let E;try{E=await o(w).process(h,{from:y,to:g,map:{inline:!1,annotation:!1}})}catch(e){if(reduceInformationInCssSyntaxError(e),u.exception&&u.exception.test(e.message))return;throw e}e.ok(!u.exception,new OutcomeError(`expected an exception matching "${u.exception}"`,y));const x=E.css.toString();{const e=[t.writeFile(g,x,"utf8")];process.env.REWRITE_EXPECTS&&e.push(t.writeFile(m,x,"utf8")),await Promise.all(e)}k||e.ok(s.existsSync(m),new OutcomeError(`Missing expect file: "${m}"`,y)),await i.test("has expected output",(()=>{e.deepEqual(x,k),e.deepEqual(E.warnings().length,u.warnings??0,"Unexpected number warnings")})),await i.test("sourcemaps",(async()=>{e.ok(!E.map.toJSON().sources.includes("<no source>"),'Sourcemap is broken. This is most likely a newly created PostCSS AST Node without a value for "source". See: https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes')})),u.after&&await u.after(),await i.test("output is parsable with PostCSS",(async()=>{const t=await fileContentsOrEmptyString(g),s=await o([noopPlugin()]).process(t,{from:g,to:g,map:{inline:!1,annotation:!1}});e.deepEqual(s.warnings(),[],"Unexpected warnings on second pass")})),await i.test("The oldest and current PostCSS version produce the same result",{skip:o([noopPlugin()]).version===n([noopPlugin()]).version},(async()=>{const t=await n(w).process(h,{from:y,to:g,map:{inline:!1,annotation:!1}});e.deepEqual(t.css.toString(),x)}))}))}))}},exports.ruleClonerPlugin=c;
/* node:coverage enable */
