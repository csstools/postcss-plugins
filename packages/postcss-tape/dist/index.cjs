/* node:coverage disable */
"use strict";var s=require("fs/promises"),e=require("path"),t=require("postcss"),o=require("postcss-8.4"),n=require("postcss-html"),r=require("node:assert/strict"),c=require("node:test");const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});function reduceInformationInCssSyntaxError(s){process.env.DEBUG||(delete s.source,s.input&&delete s.input.source,delete s.postcssNode)}async function fileContentsOrEmptyString(e){try{return await s.readFile(e,"utf8")}catch(s){return""}}function postcssSyntax(s){if(s.postcssSyntaxHTML)return n()}function postcssSyntaxSupportsSourceMaps(s){return!s.postcssSyntaxHTML}noopPlugin.postcss=!0;const a={postcssPlugin:"declaration-cloner",Declaration(s){"to-clone"===s.prop&&s.cloneBefore({prop:"cloned"})}},i={postcssPlugin:"rule-cloner",prepare(){const s=new WeakSet;return{RuleExit(e){s.has(e)||"to-clone"===e.selector&&(s.add(e),e.cloneBefore({selector:"cloned"}))}}}},p={postcssPlugin:"at-rule-cloner",prepare(){const s=new WeakSet;return{AtRuleExit(e){if(!s.has(e))return"to-clone"===e.params?(s.add(e),void e.cloneBefore({params:"cloned"})):"to-clone"===e.name?(s.add(e),void e.cloneBefore({name:"cloned"})):void 0}}}};exports.atRuleClonerPlugin=p,exports.declarationClonerPlugin=a,exports.postcssTape=function postcssTape(n,a){a=a??{},c("`postcss` flag is set on exported plugin creator",(()=>{r.strictEqual(n.postcss,!0)})),c("exported plugin creator is a function",(()=>{r.strictEqual(typeof n,"function")})),c("`postcssPlugin` is set on a plugin instance",(()=>{const s=n();r.ok(s.postcssPlugin),r.strictEqual(typeof s.postcssPlugin,"string")})),c("package.json",(async e=>{const t=await s.readFile("./package.json","utf-8"),o=JSON.parse(t);await e.test('includes "postcss-plugin" keyword',(()=>{r.ok(o.keywords),r.ok(o.keywords.includes("postcss-plugin"))}));const c=a?.skipPackageNameCheck||["css-has-pseudo","css-blank-pseudo","css-prefers-color-scheme","@csstools/css-has-pseudo-experimental"].includes(o.name);await e.test('name starts with "postcss-"',{skip:c},(()=>{let s=o.name;if(s.startsWith("@")){s=o.name.split("/").slice(1).join("/")}r.ok(s.startsWith("postcss-"),`package name "${s}" does not start with "postcss-"`)})),await e.test("`postcss` is a peer dependency and not a direct dependency",{skip:"postcssTapeSelfTest"in n},(()=>{r.ok(o.peerDependencies),r.ok(Object.keys(Object(o.peerDependencies)).includes("postcss")),r.ok(!Object.keys(Object(o.dependencies)).includes("postcss"))}))}));const i=n().postcssPlugin;return async a=>{await c(i,(async c=>{for(const i in a)await c.test(i,(async c=>{const p=a[i];p.before&&await p.before();const u=e.join(".","test",i.split(":")[0]),l=e.join(".","test",i.replace(/:/g,"."));let d="css";p.postcssSyntaxHTML&&(d="html");const S=`${u}.${d}`;let f=`${l}.expect.${d}`,g=`${l}.result.${d}`;p.expect&&(f=e.join(".","test",p.expect)),p.result&&(g=e.join(".","test",p.result));const y=p.plugins??[n(p.options)],m=await fileContentsOrEmptyString(S),w=await fileContentsOrEmptyString(f);let x,k=!1;try{x=await t(y).process(m,{from:S,to:g,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1},syntax:postcssSyntax(p)})}catch(s){if(reduceInformationInCssSyntaxError(s),k=!0,p.exception&&p.exception.test(s.message))return;r.ifError(s)}r.notEqual(!k,p.exception,"expected an exception but got none");const h=x.css.toString();{const e=[s.writeFile(g,h,"utf8")];process.env.REWRITE_EXPECTS&&e.push(s.writeFile(f,h,"utf8")),await Promise.all(e)}r.ok(w,"Missing expected result file"),await c.test("has expected output",(()=>{r.strictEqual(h,w),r.deepStrictEqual(x.warnings().length,p.warnings??0,"Unexpected number warnings")})),await c.test("sourcemaps",{skip:!postcssSyntaxSupportsSourceMaps(p)},(async()=>{r.ok(!x.map.toJSON().sources.includes("<no source>"),'Sourcemap is broken. This is most likely a newly created PostCSS AST Node without a value for "source". See: https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes')})),p.after&&await p.after(),await c.test("output is parsable with PostCSS",(async()=>{const s=await fileContentsOrEmptyString(g),e=await t([noopPlugin()]).process(s,{from:g,to:g,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1},syntax:postcssSyntax(p)});r.deepStrictEqual(e.warnings(),[],"Unexpected warnings on second pass")})),await c.test("The oldest and current PostCSS version produce the same result",{skip:t([noopPlugin()]).version===o([noopPlugin()]).version},(async()=>{const s=await o(y).process(m,{from:S,to:g,map:!!postcssSyntaxSupportsSourceMaps(p)&&{inline:!1,annotation:!1}});r.strictEqual(s.css.toString(),h)}))}))}))}},exports.ruleClonerPlugin=i;
/* node:coverage enable */
