"use strict";var e,t=require("@csstools/css-parser-algorithms"),n=require("@csstools/css-tokenizer");exports.NodeType=void 0,(e=exports.NodeType||(exports.NodeType={})).CustomFunction="custom-function",e.FunctionParameter="function-parameter";class CustomFunction{type=exports.NodeType.CustomFunction;function;parameters;returnsKeyword;returnType;before;after;constructor(e,t,n,r,o=[],s=[]){this.function=e,this.parameters=t,this.returnsKeyword=n,this.returnType=r,this.before=o,this.after=s}getName(){return this.function.getName()}getReturnType(){const e=t.parseListOfComponentValues(this.returnType).filter((e=>!t.isWhiteSpaceOrCommentNode(e)));return 1===e.length&&t.isFunctionNode(e[0])&&"type"===e[0].getName().toLowerCase()?n.stringify(...e[0].value.flatMap((e=>e.tokens())).filter((e=>!n.isTokenComment(e)))).trim():n.stringify(...this.returnType.filter((e=>!n.isTokenComment(e)))).trim()}tokens(){return[...this.before,...this.function.tokens(),...this.returnsKeyword,...this.returnType,...this.after]}toString(){return n.stringify(...this.before)+n.stringify(...this.function.tokens())+n.stringify(...this.returnsKeyword)+n.stringify(...this.returnType)+n.stringify(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),tokens:this.tokens(),parameters:this.parameters.map((e=>e.toJSON())),returnsKeyword:this.returnsKeyword,returnType:this.returnType,before:this.before,after:this.after}}isCustomFunction(){return CustomFunction.isCustomFunction(this)}static isCustomFunction(e){return!!e&&(e instanceof CustomFunction&&e.type===exports.NodeType.CustomFunction)}}class FunctionParameter{type=exports.NodeType.FunctionParameter;name;argumentType;colon;defaultValue;before;after;constructor(e,t,n,r,o=[],s=[]){this.name=e,this.argumentType=t,this.colon=n,this.defaultValue=r,this.before=o,this.after=s}getName(){return this.name[4].value}getNameToken(){return this.name}getArgumentType(){return n.stringify(...this.argumentType.filter((e=>!n.isTokenComment(e)))).trim()}getDefaultValue(){return n.stringify(...this.defaultValue).trim()}toJSON(){return{type:this.type,name:this.getName(),argumentType:this.argumentType,colon:this.colon,defaultValue:this.defaultValue,before:this.before,after:this.after}}isFunctionParameter(){return FunctionParameter.isFunctionParameter(this)}static isFunctionParameter(e){return!!e&&(e instanceof FunctionParameter&&e.type===exports.NodeType.FunctionParameter)}}function parseCustomFunction(e){let r=null,o=-1,s=-1,i=-1,a=e.length;for(let a=0;a<e.length;a++){const u=e[a];if(!t.isWhiteSpaceOrCommentNode(u))if(-1===o&&t.isFunctionNode(u)){if(!u.getName().startsWith("--"))return!1;o=a,r=u}else{if(-1===o||-1!==s||!t.isTokenNode(u)){if(-1!==s){i=a;break}return!1}{const e=u.value;if(!n.isTokenIdent(e))return!1;if("returns"!==e[4].value.toLowerCase())return!1;s=a}}}if(-1!==s&&-1===i)return!1;if(!r)return!1;for(let n=e.length-1;n>i;n--){const r=e[n];if(!t.isWhiteSpaceOrCommentNode(r))break;a=n}const u=parseFunctionParameters(r.value);return!!u&&new CustomFunction(r,u,-1===i?[]:e.slice(o+1,i).flatMap((e=>e.tokens())),-1===i?[]:e.slice(i,a).flatMap((e=>e.tokens())),e.slice(0,o).flatMap((e=>e.tokens())),e.slice(a).flatMap((e=>e.tokens())))}function parseFunctionParameters(e){if(!e.some((e=>!t.isWhiteSpaceOrCommentNode(e))))return[];const n=[];for(let t=0;t<e.length;t++){const r=parseFunctionParameter(e.slice(t));if(!r)return!1;t+=r.advance,n.push(r.node)}return n}function parseFunctionParameter(e){let r=0,o=-1,s=null,i=-1,a=null,u=-1,c=e.length,l=0;for(l=0;l<e.length;l++){const m=e[l];if(!t.isWhiteSpaceOrCommentNode(m)){if(0===r&&t.isTokenNode(m)&&n.isTokenComma(m.value)){c=l;break}if(-1===o){if(t.isTokenNode(m)&&n.isTokenIdent(m.value)&&m.value[4].value.startsWith("--")){o=l,s=m.value;continue}return!1}if(-1===i&&t.isTokenNode(m)&&n.isTokenDelim(m.value)&&"<"===m.value[4].value)r++;else if(-1===i&&r>0&&t.isTokenNode(m)&&n.isTokenDelim(m.value)&&">"===m.value[4].value)r--;else if(-1===i&&0===r&&t.isTokenNode(m)&&n.isTokenColon(m.value))i=l,a=m.value;else if(-1===i){if(-1!==i)return!1}else u=l}}if(!s)return!1;if(-1!==i&&-1===u)return!1;const m=-1!==i?i-1:l-1;for(let n=e.length-1;n>Math.max(m,u);n--){const r=e[n];if(!t.isWhitespaceNode(r))break;c=n}let f=[];{const n=e.slice(o+1,m+1),r=n.filter((e=>!t.isWhiteSpaceOrCommentNode(e)));f=1===r.length&&t.isFunctionNode(r[0])&&"type"===r[0].getName().toLowerCase()?r[0].value.flatMap((e=>e.tokens())):n.flatMap((e=>e.tokens()))}let p=[];if(-1!==u){const r=e.slice(i+1,c),o=r.filter((e=>!t.isWhiteSpaceOrCommentNode(e)));p=1===o.length&&t.isSimpleBlockNode(o[0])&&n.isTokenOpenCurly(o[0].startToken)?o[0].value.flatMap((e=>e.tokens())):r.flatMap((e=>e.tokens()))}return{advance:l,node:new FunctionParameter(s,f,a,p,e.slice(0,o).flatMap((e=>e.tokens())),e.slice(c,l+1).flatMap((e=>e.tokens())))}}function parseFromTokens(e,n){return parseCustomFunction(t.parseListOfComponentValues(e,{onParseError:n?.onParseError}))}exports.CustomFunction=CustomFunction,exports.FunctionParameter=FunctionParameter,exports.isCustomFunction=function isCustomFunction(e){return CustomFunction.isCustomFunction(e)},exports.isFunctionParameter=function isFunctionParameter(e){return FunctionParameter.isFunctionParameter(e)},exports.parse=function parse(e,t){return parseFromTokens(n.tokenize({css:e},{onParseError:t?.onParseError}),t)},exports.parseFromTokens=parseFromTokens;
