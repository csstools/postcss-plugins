"use strict";var e,t=require("@csstools/css-parser-algorithms"),r=require("@csstools/css-tokenizer");exports.NodeType=void 0,(e=exports.NodeType||(exports.NodeType={})).CustomFunction="custom-function",e.FunctionParameter="function-parameter";class CustomFunction{type=exports.NodeType.CustomFunction;function;parameters;returnsKeyword;returnType;before;after;constructor(e,t,r,n,s=[],i=[]){this.function=e,this.parameters=t,this.returnsKeyword=r,this.returnType=n,this.before=s,this.after=i}getName(){return this.function.getName()}tokens(){return[...this.before,...this.function.tokens(),...this.returnsKeyword,...this.returnType,...this.after]}toString(){return r.stringify(...this.before)+r.stringify(...this.function.tokens())+r.stringify(...this.returnsKeyword)+r.stringify(...this.returnType)+r.stringify(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),tokens:this.tokens(),parameters:this.parameters.map((e=>e.toJSON())),returnsKeyword:this.returnsKeyword,returnType:this.returnType,before:this.before,after:this.after}}isCustomFunction(){return CustomFunction.isCustomFunction(this)}static isCustomFunction(e){return!!e&&(e instanceof CustomFunction&&e.type===exports.NodeType.CustomFunction)}}class FunctionParameter{type=exports.NodeType.FunctionParameter;name;argumentType;colon;defaultValue;before;after;constructor(e,t,r,n,s=[],i=[]){this.name=e,this.argumentType=t,this.colon=r,this.defaultValue=n,this.before=s,this.after=i}getName(){return this.name[4].value}getNameToken(){return this.name}getArgumentType(){return r.stringify(...this.argumentType.filter((e=>!r.isTokenComment(e)))).trim()}getDefaultValue(){return r.stringify(...this.defaultValue).trim()}tokens(){return[...this.before,this.name,...this.argumentType,this.colon,...this.defaultValue,...this.after].filter((e=>!!e))}toString(){return r.stringify(...this.before)+r.stringify(this.name)+r.stringify(...this.argumentType)+(this.colon?r.stringify(this.colon):"")+r.stringify(...this.defaultValue)+r.stringify(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),argumentType:this.argumentType,colon:this.colon,defaultValue:this.defaultValue,before:this.before,after:this.after}}isFunctionParameter(){return FunctionParameter.isFunctionParameter(this)}static isFunctionParameter(e){return!!e&&(e instanceof FunctionParameter&&e.type===exports.NodeType.FunctionParameter)}}function parseCustomFunction(e){let n=null,s=-1,i=-1,o=-1,a=e.length;for(let a=0;a<e.length;a++){const u=e[a];if(!t.isWhiteSpaceOrCommentNode(u))if(-1===s&&t.isFunctionNode(u)){if(!u.getName().startsWith("--"))return!1;s=a,n=u}else{if(-1===s||-1!==i||!t.isTokenNode(u)){if(-1!==i){o=a;break}return!1}{const e=u.value;if(!r.isTokenIdent(e))return!1;if("returns"!==e[4].value.toLowerCase())return!1;i=a}}}if(-1!==i&&-1===o)return!1;if(!n)return!1;for(let r=e.length-1;r>o;r--){const n=e[r];if(!t.isWhiteSpaceOrCommentNode(n))break;a=r}const u=parseFunctionParameters(n.value);return!!u&&new CustomFunction(n,u,-1===o?[]:e.slice(s+1,o).flatMap((e=>e.tokens())),-1===o?[]:e.slice(o,a).flatMap((e=>e.tokens())),e.slice(0,s).flatMap((e=>e.tokens())),e.slice(a).flatMap((e=>e.tokens())))}function parseFunctionParameters(e){if(!e.some((e=>!t.isWhiteSpaceOrCommentNode(e))))return[];const r=[];for(let t=0;t<e.length;t++){const n=parseFunctionParameter(e.slice(t));if(!n)return!1;t+=n.advance,r.push(n.node)}return r}function parseFunctionParameter(e){let n=0,s=-1,i=null,o=-1,a=null,u=-1,c=e.length,f=0;for(f=0;f<e.length;f++){const l=e[f];if(!t.isWhiteSpaceOrCommentNode(l)){if(0===n&&t.isTokenNode(l)&&r.isTokenComma(l.value)){c=f;break}if(-1===s){if(t.isTokenNode(l)&&r.isTokenIdent(l.value)&&l.value[4].value.startsWith("--")){s=f,i=l.value;continue}return!1}if(-1===o&&t.isTokenNode(l)&&r.isTokenDelim(l.value)&&"<"===l.value[4].value)n++;else if(-1===o&&n>0&&t.isTokenNode(l)&&r.isTokenDelim(l.value)&&">"===l.value[4].value)n--;else if(-1===o&&0===n&&t.isTokenNode(l)&&r.isTokenColon(l.value))o=f,a=l.value;else if(-1===o){if(-1!==o)return!1}else u=f}}if(!i)return!1;if(-1!==o&&-1===u)return!1;const l=-1!==o?o-1:f-1;for(let r=e.length-1;r>Math.max(l,u);r--){const n=e[r];if(!t.isWhitespaceNode(n))break;c=r}let m=[];if(-1!==u){const n=e.slice(o+1,c),s=n.filter((e=>!t.isWhiteSpaceOrCommentNode(e)));m=1===s.length&&t.isSimpleBlockNode(s[0])&&r.isTokenOpenCurly(s[0].startToken)?s[0].value.flatMap((e=>e.tokens())):n.flatMap((e=>e.tokens()))}return{advance:f,node:new FunctionParameter(i,e.slice(s+1,l+1).flatMap((e=>e.tokens())),a,m,e.slice(0,s).flatMap((e=>e.tokens())),e.slice(c,f+1).flatMap((e=>e.tokens())))}}function parseFromTokens(e,r){return parseCustomFunction(t.parseListOfComponentValues(e,{onParseError:r?.onParseError}))}exports.CustomFunction=CustomFunction,exports.FunctionParameter=FunctionParameter,exports.isCustomFunction=function isCustomFunction(e){return CustomFunction.isCustomFunction(e)},exports.isFunctionParameter=function isFunctionParameter(e){return FunctionParameter.isFunctionParameter(e)},exports.parse=function parse(e,t){return parseFromTokens(r.tokenize({css:e},{onParseError:t?.onParseError}),t)},exports.parseFromTokens=parseFromTokens;
