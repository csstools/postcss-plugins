import{parseListOfComponentValues as t,isWhiteSpaceOrCommentNode as e,isFunctionNode as r,isTokenNode as n,isWhitespaceNode as s,isSimpleBlockNode as o}from"@csstools/css-parser-algorithms";import{stringify as a,isTokenComment as i,isTokenIdent as u,isTokenComma as l,isTokenDelim as c,isTokenColon as f,isTokenOpenCurly as m,tokenize as h}from"@csstools/css-tokenizer";var p;!function(t){t.CustomFunction="custom-function",t.FunctionParameter="function-parameter"}(p||(p={}));class CustomFunction{type=p.CustomFunction;function;parameters;returnsKeyword;returnType;before;after;constructor(t,e,r,n,s=[],o=[]){this.function=t,this.parameters=e,this.returnsKeyword=r,this.returnType=n,this.before=s,this.after=o}getName(){return this.function.getName()}getReturnType(){const n=t(this.returnType).filter((t=>!e(t)));return 1===n.length&&r(n[0])&&"type"===n[0].getName().toLowerCase()?a(...n[0].value.flatMap((t=>t.tokens())).filter((t=>!i(t)))).trim():a(...this.returnType.filter((t=>!i(t)))).trim()}tokens(){return[...this.before,...this.function.tokens(),...this.returnsKeyword,...this.returnType,...this.after]}toString(){return a(...this.before)+a(...this.function.tokens())+a(...this.returnsKeyword)+a(...this.returnType)+a(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),tokens:this.tokens(),parameters:this.parameters.map((t=>t.toJSON())),returnsKeyword:this.returnsKeyword,returnType:this.returnType,before:this.before,after:this.after}}isCustomFunction(){return CustomFunction.isCustomFunction(this)}static isCustomFunction(t){return!!t&&(t instanceof CustomFunction&&t.type===p.CustomFunction)}}class FunctionParameter{type=p.FunctionParameter;name;argumentType;colon;defaultValue;before;after;constructor(t,e,r,n,s=[],o=[]){this.name=t,this.argumentType=e,this.colon=r,this.defaultValue=n,this.before=s,this.after=o}getName(){return this.name[4].value}getNameToken(){return this.name}getArgumentType(){return a(...this.argumentType.filter((t=>!i(t)))).trim()}getDefaultValue(){return a(...this.defaultValue).trim()}toJSON(){return{type:this.type,name:this.getName(),argumentType:this.argumentType,colon:this.colon,defaultValue:this.defaultValue,before:this.before,after:this.after}}isFunctionParameter(){return FunctionParameter.isFunctionParameter(this)}static isFunctionParameter(t){return!!t&&(t instanceof FunctionParameter&&t.type===p.FunctionParameter)}}function parseCustomFunction(t){let s=null,o=-1,a=-1,i=-1,l=t.length;for(let l=0;l<t.length;l++){const c=t[l];if(!e(c))if(-1===o&&r(c)){if(!c.getName().startsWith("--"))return!1;o=l,s=c}else{if(-1===o||-1!==a||!n(c)){if(-1!==a){i=l;break}return!1}{const t=c.value;if(!u(t))return!1;if("returns"!==t[4].value.toLowerCase())return!1;a=l}}}if(-1!==a&&-1===i)return!1;if(!s)return!1;for(let r=t.length-1;r>i;r--){const n=t[r];if(!e(n))break;l=r}const c=parseFunctionParameters(s.value);return!!c&&new CustomFunction(s,c,-1===i?[]:t.slice(o+1,i).flatMap((t=>t.tokens())),-1===i?[]:t.slice(i,l).flatMap((t=>t.tokens())),t.slice(0,o).flatMap((t=>t.tokens())),t.slice(l).flatMap((t=>t.tokens())))}function parseFunctionParameters(t){if(!t.some((t=>!e(t))))return[];const r=[];for(let e=0;e<t.length;e++){const n=parseFunctionParameter(t.slice(e));if(!n)return!1;e+=n.advance,r.push(n.node)}return r}function parseFunctionParameter(t){let a=0,i=-1,h=null,p=-1,F=null,g=-1,y=t.length,k=0;for(k=0;k<t.length;k++){const r=t[k];if(!e(r)){if(0===a&&n(r)&&l(r.value)){y=k;break}if(-1===i){if(n(r)&&u(r.value)&&r.value[4].value.startsWith("--")){i=k,h=r.value;continue}return!1}if(-1===p&&n(r)&&c(r.value)&&"<"===r.value[4].value)a++;else if(-1===p&&a>0&&n(r)&&c(r.value)&&">"===r.value[4].value)a--;else if(-1===p&&0===a&&n(r)&&f(r.value))p=k,F=r.value;else if(-1===p){if(-1!==p)return!1}else g=k}}if(!h)return!1;if(-1!==p&&-1===g)return!1;const v=-1!==p?p-1:k-1;for(let e=t.length-1;e>Math.max(v,g);e--){const r=t[e];if(!s(r))break;y=e}let P=[];{const n=t.slice(i+1,v+1),s=n.filter((t=>!e(t)));P=1===s.length&&r(s[0])&&"type"===s[0].getName().toLowerCase()?s[0].value.flatMap((t=>t.tokens())):n.flatMap((t=>t.tokens()))}let C=[];if(-1!==g){const r=t.slice(p+1,y),n=r.filter((t=>!e(t)));C=1===n.length&&o(n[0])&&m(n[0].startToken)?n[0].value.flatMap((t=>t.tokens())):r.flatMap((t=>t.tokens()))}return{advance:k,node:new FunctionParameter(h,P,F,C,t.slice(0,i).flatMap((t=>t.tokens())),t.slice(y,k+1).flatMap((t=>t.tokens())))}}function parseFromTokens(e,r){return parseCustomFunction(t(e,{onParseError:r?.onParseError}))}function parse(t,e){return parseFromTokens(h({css:t},{onParseError:e?.onParseError}),e)}function isCustomFunction(t){return CustomFunction.isCustomFunction(t)}function isFunctionParameter(t){return FunctionParameter.isFunctionParameter(t)}export{CustomFunction,FunctionParameter,p as NodeType,isCustomFunction,isFunctionParameter,parse,parseFromTokens};
