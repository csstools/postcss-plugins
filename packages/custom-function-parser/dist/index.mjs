import{isWhiteSpaceOrCommentNode as t,isFunctionNode as e,isTokenNode as r,isWhitespaceNode as n,isSimpleBlockNode as s,parseListOfComponentValues as i}from"@csstools/css-parser-algorithms";import{stringify as o,isTokenComment as a,isTokenIdent as u,isTokenComma as c,isTokenDelim as f,isTokenColon as l,isTokenOpenCurly as m,tokenize as h}from"@csstools/css-tokenizer";var p;!function(t){t.CustomFunction="custom-function",t.FunctionParameter="function-parameter"}(p||(p={}));class CustomFunction{type=p.CustomFunction;function;parameters;returnsKeyword;returnType;before;after;constructor(t,e,r,n,s=[],i=[]){this.function=t,this.parameters=e,this.returnsKeyword=r,this.returnType=n,this.before=s,this.after=i}getName(){return this.function.getName()}tokens(){return[...this.before,...this.function.tokens(),...this.returnsKeyword,...this.returnType,...this.after]}toString(){return o(...this.before)+o(...this.function.tokens())+o(...this.returnsKeyword)+o(...this.returnType)+o(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),tokens:this.tokens(),parameters:this.parameters.map((t=>t.toJSON())),returnsKeyword:this.returnsKeyword,returnType:this.returnType,before:this.before,after:this.after}}isCustomFunction(){return CustomFunction.isCustomFunction(this)}static isCustomFunction(t){return!!t&&(t instanceof CustomFunction&&t.type===p.CustomFunction)}}class FunctionParameter{type=p.FunctionParameter;name;argumentType;colon;defaultValue;before;after;constructor(t,e,r,n,s=[],i=[]){this.name=t,this.argumentType=e,this.colon=r,this.defaultValue=n,this.before=s,this.after=i}getName(){return this.name[4].value}getNameToken(){return this.name}getArgumentType(){return o(...this.argumentType.filter((t=>!a(t)))).trim()}getDefaultValue(){return o(...this.defaultValue).trim()}tokens(){return[...this.before,this.name,...this.argumentType,this.colon,...this.defaultValue,...this.after].filter((t=>!!t))}toString(){return o(...this.before)+o(this.name)+o(...this.argumentType)+(this.colon?o(this.colon):"")+o(...this.defaultValue)+o(...this.after)}toJSON(){return{type:this.type,name:this.getName(),string:this.toString(),argumentType:this.argumentType,colon:this.colon,defaultValue:this.defaultValue,before:this.before,after:this.after}}isFunctionParameter(){return FunctionParameter.isFunctionParameter(this)}static isFunctionParameter(t){return!!t&&(t instanceof FunctionParameter&&t.type===p.FunctionParameter)}}function parseCustomFunction(n){let s=null,i=-1,o=-1,a=-1,c=n.length;for(let c=0;c<n.length;c++){const f=n[c];if(!t(f))if(-1===i&&e(f)){if(!f.getName().startsWith("--"))return!1;i=c,s=f}else{if(-1===i||-1!==o||!r(f)){if(-1!==o){a=c;break}return!1}{const t=f.value;if(!u(t))return!1;if("returns"!==t[4].value.toLowerCase())return!1;o=c}}}if(-1!==o&&-1===a)return!1;if(!s)return!1;for(let e=n.length-1;e>a;e--){const r=n[e];if(!t(r))break;c=e}const f=parseFunctionParameters(s.value);return!!f&&new CustomFunction(s,f,-1===a?[]:n.slice(i+1,a).flatMap((t=>t.tokens())),-1===a?[]:n.slice(a,c).flatMap((t=>t.tokens())),n.slice(0,i).flatMap((t=>t.tokens())),n.slice(c).flatMap((t=>t.tokens())))}function parseFunctionParameters(e){if(!e.some((e=>!t(e))))return[];const r=[];for(let t=0;t<e.length;t++){const n=parseFunctionParameter(e.slice(t));if(!n)return!1;t+=n.advance,r.push(n.node)}return r}function parseFunctionParameter(e){let i=0,o=-1,a=null,h=-1,p=null,F=-1,g=e.length,y=0;for(y=0;y<e.length;y++){const n=e[y];if(!t(n)){if(0===i&&r(n)&&c(n.value)){g=y;break}if(-1===o){if(r(n)&&u(n.value)&&n.value[4].value.startsWith("--")){o=y,a=n.value;continue}return!1}if(-1===h&&r(n)&&f(n.value)&&"<"===n.value[4].value)i++;else if(-1===h&&i>0&&r(n)&&f(n.value)&&">"===n.value[4].value)i--;else if(-1===h&&0===i&&r(n)&&l(n.value))h=y,p=n.value;else if(-1===h){if(-1!==h)return!1}else F=y}}if(!a)return!1;if(-1!==h&&-1===F)return!1;const k=-1!==h?h-1:y-1;for(let t=e.length-1;t>Math.max(k,F);t--){const r=e[t];if(!n(r))break;g=t}let P=[];if(-1!==F){const r=e.slice(h+1,g),n=r.filter((e=>!t(e)));P=1===n.length&&s(n[0])&&m(n[0].startToken)?n[0].value.flatMap((t=>t.tokens())):r.flatMap((t=>t.tokens()))}return{advance:y,node:new FunctionParameter(a,e.slice(o+1,k+1).flatMap((t=>t.tokens())),p,P,e.slice(0,o).flatMap((t=>t.tokens())),e.slice(g,y+1).flatMap((t=>t.tokens())))}}function parseFromTokens(t,e){return parseCustomFunction(i(t,{onParseError:e?.onParseError}))}function parse(t,e){return parseFromTokens(h({css:t},{onParseError:e?.onParseError}),e)}function isCustomFunction(t){return CustomFunction.isCustomFunction(t)}function isFunctionParameter(t){return FunctionParameter.isFunctionParameter(t)}export{CustomFunction,FunctionParameter,p as NodeType,isCustomFunction,isFunctionParameter,parse,parseFromTokens};
