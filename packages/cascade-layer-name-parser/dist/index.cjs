"use strict";var e=require("@csstools/css-tokenizer"),n=require("@csstools/css-parser-algorithms");class LayerName{parts;constructor(e){this.parts=e}tokens(){return[...this.parts]}slice(n,r){const t=[];for(let n=0;n<this.parts.length;n++)e.isTokenIdent(this.parts[n])&&t.push(n);const s=t.slice(n,r);return new LayerName(this.parts.slice(s[0],s[s.length-1]+1))}concat(n){const r=[e.TokenType.Delim,".",-1,-1,{value:"."}];return new LayerName([...this.parts.filter((n=>e.isTokenIdent(n)||e.isTokenDelim(n))),r,...n.parts.filter((n=>e.isTokenIdent(n)||e.isTokenDelim(n)))])}segments(){return this.parts.filter((n=>e.isTokenIdent(n))).map((e=>e[4].value))}name(){return this.parts.filter((n=>e.isTokenIdent(n)||e.isTokenDelim(n))).map((e=>e[1])).join("")}equal(e){const n=this.segments(),r=e.segments();if(n.length!==r.length)return!1;for(let e=0;e<n.length;e++){if(n[e]!==r[e])return!1}return!0}toString(){return e.stringify(...this.parts)}toJSON(){return{parts:this.parts,segments:this.segments(),name:this.name()}}}function parseFromTokens(r,t){const s=n.parseCommaSeparatedListOfComponentValues(r,{onParseError:t?.onParseError}),a=t?.onParseError??(()=>{}),o=["6.4.2. Layer Naming and Nesting","Layer name syntax","<layer-name> = <ident> [ '.' <ident> ]*"],i=r[0][2],l=r[r.length-1][3],m=[];for(let r=0;r<s.length;r++){const t=s[r];for(let r=0;r<t.length;r++){const s=t[r];if(!n.isTokenNode(s)&&!n.isCommentNode(s)&&!n.isWhitespaceNode(s))return a(new e.ParseError(`Invalid cascade layer name. Invalid layer name part "${s.toString()}"`,i,l,o)),[]}const c=t.flatMap((e=>e.tokens()));let d=!1,p=!1,u=null;for(let n=0;n<c.length;n++){const r=c[n];if(!(e.isTokenComment(r)||e.isTokenWhitespace(r)||e.isTokenIdent(r)||e.isTokenDelim(r)&&"."===r[4].value))return a(new e.ParseError(`Invalid cascade layer name. Invalid character "${r[1]}"`,i,l,o)),[];if(!d&&e.isTokenDelim(r))return a(new e.ParseError("Invalid cascade layer name. Layer names can not start with a dot.",i,l,o)),[];if(d){if(e.isTokenWhitespace(r)){p=!0;continue}if(p&&e.isTokenComment(r))continue;if(p)return a(new e.ParseError("Invalid cascade layer name. Encountered unexpected whitespace between layer name parts.",i,l,o)),[];if(e.isTokenIdent(u)&&e.isTokenIdent(r))return a(new e.ParseError("Invalid cascade layer name. Layer name parts must be separated by dots.",i,l,o)),[];if(e.isTokenDelim(u)&&e.isTokenDelim(r))return a(new e.ParseError("Invalid cascade layer name. Layer name parts must not be empty.",i,l,o)),[]}e.isTokenIdent(r)&&(d=!0),(e.isTokenIdent(r)||e.isTokenDelim(r))&&(u=r)}if(!u)return a(new e.ParseError("Invalid cascade layer name. Empty layer name.",i,l,o)),[];if(e.isTokenDelim(u))return a(new e.ParseError("Invalid cascade layer name. Layer name must not end with a dot.",i,l,o)),[];m.push(new LayerName(c))}return m}exports.LayerName=LayerName,exports.addLayerToModel=function addLayerToModel(e,n){n.forEach((n=>{const r=n.segments();e:for(let t=0;t<r.length;t++){const r=n.slice(0,t+1),s=r.segments();let a=-1,o=0;for(let n=0;n<e.length;n++){const r=e[n].segments();let t=0;n:for(let e=0;e<r.length;e++){const n=r[e],a=s[e];if(a===n&&e+1===s.length)continue e;if(a!==n){if(a!==n)break n}else t++}t>=o&&(a=n,o=t)}-1===a?e.push(r):e.splice(a+1,0,r)}}))},exports.parse=function parse(n,r){const t=e.tokenizer({css:n},{onParseError:r?.onParseError}),s=[];for(;!t.endOfFile();)s.push(t.nextToken());return s.push(t.nextToken()),parseFromTokens(s,r)},exports.parseFromTokens=parseFromTokens;
