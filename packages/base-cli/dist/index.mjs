import t from"postcss";import e from"path";import{promises as n}from"fs";var i;function parseArguments(t,e,n){const s=t.map((t=>t.trim())).filter((t=>!!t)),o={stdin:!1,stdout:!1,output:void 0,outputDir:void 0,inputs:[],inlineMap:!0,externalMap:!1,replace:!1,pluginOptions:{},debug:!1};let r,a=!1;for(let t=0;t<s.length;t++){const e=s[t];switch(e){case"-o":case"--output":o.output=s[t+1],t++,a=!0;break;case"-m":case"--map":o.externalMap=!0,o.inlineMap=!1,a=!0;break;case"--no-map":o.externalMap=!1,o.inlineMap=!1,a=!0;break;case"-r":case"--replace":o.replace=!0,a=!0;break;case"--debug":o.debug=!0,a=!0;break;case"-d":case"--dir":o.outputDir=s[t+1],t++,a=!0;break;case"-p":case"--plugin-options":r=s[t+1],t++,a=!0;break;default:if(0===e.indexOf("-"))return console.warn(`[error] unknown argument : ${e}\n`),n(),i.InvalidArguments;if(!a){o.inputs.push(e);break}return n(),i.InvalidArguments}}if(o.replace&&(o.output=void 0,o.outputDir=void 0),o.outputDir&&(o.output=void 0),o.inputs.length>1&&o.output)return console.warn('[error] omit "--output" when processing multiple inputs\n'),n(),i.InvalidArguments;0===o.inputs.length&&(o.stdin=!0),o.output||o.outputDir||o.replace||(o.stdout=!0),o.stdout&&(o.externalMap=!1);let p={};if(r)try{p=JSON.parse(r)}catch(t){return console.warn("[error] plugin options must be valid JSON\n"),n(),i.InvalidArguments}for(const t in p){const s=p[t];if(!e.includes(t))return console.warn(`[error] unknown plugin option: ${t}\n`),n(),i.InvalidArguments;o.pluginOptions[t]=s}return o}async function getStdin(){return new Promise((t=>{let e="",n=!1;if(setTimeout((()=>{n=!0,t("")}),1e4),process.stdin.isTTY){if(n)return;t(e)}else process.stdin.setEncoding("utf8"),process.stdin.on("readable",(()=>{let t;for(;t=process.stdin.read();)e+=t})),process.stdin.on("end",(()=>{n||t(e)}))}))}async function stdinToStdout(e,n,i){let s="";try{const o=await getStdin();o||(i(),process.exit(1));const r=await t([e]).process(o,{from:"stdin",to:"stdout",map:!!n.inlineMap&&{inline:!0}});r.warnings().forEach((t=>{console.warn(t.toString())})),s=r.css}catch(t){console.error(n.debug?t:t.message),process.exit(1)}process.stdout.write(s+(n.inlineMap?"\n":"")),process.exit(0)}async function stdinToFs(i,s,o){let r=s.output;!r&&s.outputDir&&(r=e.join(s.outputDir,"output.css")),r||process.exit(0);try{const e=await getStdin();e||(o(),process.exit(1));const a=await t([i]).process(e,{from:"stdin",to:r,map:!(!s.inlineMap&&!s.externalMap)&&{inline:s.inlineMap}});a.warnings().forEach((t=>{console.warn(t.toString())})),s.externalMap&&a.map?await Promise.all([await n.writeFile(r,a.css+(s.inlineMap?"\n":"")),await n.writeFile(`${r}.map`,a.map.toString())]):await n.writeFile(r,a.css+(s.inlineMap?"\n":""))}catch(t){console.error(s.debug?t:t.message),process.exit(1)}console.log(`CSS was written to "${e.normalize(r)}"`),process.exit(0)}async function fsToStdout(e,i){let s=[];try{s=await Promise.all(i.inputs.map((async i=>{const s=await n.readFile(i),o=await t([e]).process(s,{from:i,to:"stdout",map:!1});return o.warnings().forEach((t=>{console.warn(t.toString())})),o.css})))}catch(t){console.error(i.debug?t:t.message),process.exit(1)}for(const t of s)process.stdout.write(t);process.exit(0)}async function fsToFs(i,s){try{await Promise.all(s.inputs.map((async o=>{let r=s.output;s.outputDir&&(r=e.join(s.outputDir,e.basename(o))),s.replace&&(r=o),r||process.exit(0);const a=await n.readFile(o),p=await t([i]).process(a,{from:o,to:r,map:!(!s.inlineMap&&!s.externalMap)&&{inline:s.inlineMap}});p.warnings().forEach((t=>{console.warn(t.toString())})),s.externalMap&&p.map?await Promise.all([await n.writeFile(r,p.css+(s.inlineMap?"\n":"")),await n.writeFile(`${r}.map`,p.map.toString())]):await n.writeFile(r,p.css+(s.inlineMap?"\n":"")),console.log(`CSS was written to "${e.normalize(r)}"`)})))}catch(t){console.error(s.debug?t:t.message),process.exit(1)}process.exit(0)}function helpTextLogger(t,e,n,i=null){let s=[];if(i){const t=Math.max(...Object.keys(i).map((t=>t.length))),e=new Array(t).fill(" ").join("");e.length&&(s=["\nPlugin Options:",...Object.keys(i).map((t=>`  ${(t+e).slice(0,e.length)}  ${typeof i[t]}`))],s.push(`\n  ${JSON.stringify(i,null,2).split("\n").join("\n  ")}`))}const o=[`${e}\n`,`  ${n}\n`,"Usage:",`  ${t} [input.css] [OPTIONS] [-o|--output output.css]`,`  ${t} <input.css>... [OPTIONS] --dir <output-directory>`,`  ${t} <input.css>... [OPTIONS] --replace`,"\nOptions:","  -o, --output          Output file","  -d, --dir             Output directory","  -r, --replace         Replace (overwrite) the input file","  -m, --map             Create an external sourcemap","  --no-map              Disable the default inline sourcemaps","  -p, --plugin-options  Stringified JSON object with plugin options"];return s.length>0&&o.push(...s),()=>{console.warn(o.join("\n"))}}async function cli(t,e,n,s=!0){const o=parseArguments(process.argv.slice(s?2:3),e,n);o===i.InvalidArguments&&process.exit(1);const r=t(o.pluginOptions);o.stdin&&o.stdout?await stdinToStdout(r,o,n):o.stdin?await stdinToFs(r,o,n):o.stdout?await fsToStdout(r,o):await fsToFs(r,o)}!function(t){t.InvalidArguments="INVALID_ARGUMENTS"}(i||(i={}));export{cli,helpTextLogger,parseArguments};
