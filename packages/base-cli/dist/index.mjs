import t from"postcss";import e from"node:path";import n from"node:fs/promises";var o;function parseArguments(t,e,n){const s=t.map(t=>t.trim()).filter(t=>!!t),i={stdin:!1,stdout:!1,output:void 0,outputDir:void 0,inputs:[],inlineMap:!0,externalMap:!1,replace:!1,pluginOptions:{},debug:!1};let r,a=!1;for(let t=0;t<s.length;t++){const e=s[t];switch(e){case"-o":case"--output":i.output=s[t+1],t++,a=!0;break;case"-m":case"--map":i.externalMap=!0,i.inlineMap=!1,a=!0;break;case"--no-map":i.externalMap=!1,i.inlineMap=!1,a=!0;break;case"-r":case"--replace":i.replace=!0,a=!0;break;case"--debug":i.debug=!0,a=!0;break;case"-d":case"--dir":i.outputDir=s[t+1],t++,a=!0;break;case"-p":case"--plugin-options":r=s[t+1],t++,a=!0;break;default:if(0===e.indexOf("-"))return console.warn(`[error] unknown argument : ${e}\n`),n(),o.InvalidArguments;if(!a){i.inputs.push(e);break}return n(),o.InvalidArguments}}if(i.replace&&(i.output=void 0,i.outputDir=void 0),i.outputDir&&(i.output=void 0),i.inputs.length>1&&i.output)return console.warn('[error] omit "--output" when processing multiple inputs\n'),n(),o.InvalidArguments;0===i.inputs.length&&(i.stdin=!0),i.output||i.outputDir||i.replace||(i.stdout=!0),i.stdout&&(i.externalMap=!1);let p={};if(r)try{p=JSON.parse(r)}catch{return console.warn("[error] plugin options must be valid JSON\n"),n(),o.InvalidArguments}for(const t in p){const s=p[t];if(!e.includes(t))return console.warn(`[error] unknown plugin option: ${t}\n`),n(),o.InvalidArguments;i.pluginOptions[t]=s}return i}async function getStdin(){return new Promise(t=>{let e="",n=!1;if(setTimeout(()=>{n=!0,t("")},1e4),process.stdin.isTTY){if(n)return;t(e)}else process.stdin.setEncoding("utf8"),process.stdin.on("readable",()=>{let t="";for(;t=process.stdin.read();)e+=t??""}),process.stdin.on("end",()=>{n||t(e)})})}async function stdinToStdout(e,n,o){let s="";try{const i=await getStdin();i||(o(),process.exit(1));const r=await t([e]).process(i,{from:"stdin",to:"stdout",map:!!n.inlineMap&&{inline:!0}});r.warnings().forEach(t=>{console.warn(t.toString())}),s=r.css}catch(t){t instanceof Error?console.error(n.debug?t:t.message):console.error(t),process.exit(1)}process.stdout.write(s+(n.inlineMap?"\n":"")),process.exit(0)}async function stdinToFs(o,s,i){let r=s.output;!r&&s.outputDir&&(r=e.join(s.outputDir,"output.css")),r||process.exit(0);try{const e=await getStdin();e||(i(),process.exit(1));const a=await t([o]).process(e,{from:"stdin",to:r,map:!(!s.inlineMap&&!s.externalMap)&&{inline:s.inlineMap}});a.warnings().forEach(t=>{console.warn(t.toString())}),s.externalMap&&a.map?await Promise.all([await n.writeFile(r,a.css+(s.inlineMap?"\n":"")),await n.writeFile(`${r}.map`,a.map.toString())]):await n.writeFile(r,a.css+(s.inlineMap?"\n":""))}catch(t){t instanceof Error?console.error(s.debug?t:t.message):console.error(t),process.exit(1)}console.log(`CSS was written to "${e.normalize(r)}"`),process.exit(0)}async function fsToStdout(e,o){let s=[];try{s=await Promise.all(o.inputs.map(async o=>{const s=await n.readFile(o),i=await t([e]).process(s,{from:o,to:"stdout",map:!1});return i.warnings().forEach(t=>{console.warn(t.toString())}),i.css}))}catch(t){t instanceof Error?console.error(o.debug?t:t.message):console.error(t),process.exit(1)}for(const t of s)process.stdout.write(t);process.exit(0)}async function fsToFs(o,s){try{await Promise.all(s.inputs.map(async i=>{let r=s.output;s.outputDir&&(r=e.join(s.outputDir,e.basename(i))),s.replace&&(r=i),r||process.exit(0);const a=await n.readFile(i),p=await t([o]).process(a,{from:i,to:r,map:!(!s.inlineMap&&!s.externalMap)&&{inline:s.inlineMap}});p.warnings().forEach(t=>{console.warn(t.toString())}),s.externalMap&&p.map?await Promise.all([await n.writeFile(r,p.css+(s.inlineMap?"\n":"")),await n.writeFile(`${r}.map`,p.map.toString())]):await n.writeFile(r,p.css+(s.inlineMap?"\n":"")),console.log(`CSS was written to "${e.normalize(r)}"`)}))}catch(t){t instanceof Error?console.error(s.debug?t:t.message):console.error(t),process.exit(1)}process.exit(0)}function helpTextLogger(t,e,n,o=null){let s=[];if(o){const t=Math.max(...Object.keys(o).map(t=>t.length)),e=new Array(t).fill(" ").join("");e.length&&(s=["\nPlugin Options:",...Object.keys(o).map(t=>`  ${(t+e).slice(0,e.length)}  ${typeof o[t]}`)],s.push(`\n  ${JSON.stringify(o,null,2).split("\n").join("\n  ")}`))}const i=[`${e}\n`,`  ${n}\n`,"Usage:",`  ${t} [input.css] [OPTIONS] [-o|--output output.css]`,`  ${t} <input.css>... [OPTIONS] --dir <output-directory>`,`  ${t} <input.css>... [OPTIONS] --replace`,"\nOptions:","  -o, --output          Output file","  -d, --dir             Output directory","  -r, --replace         Replace (overwrite) the input file","  -m, --map             Create an external sourcemap","  --no-map              Disable the default inline sourcemaps","  -p, --plugin-options  Stringified JSON object with plugin options"];return s.length>0&&i.push(...s),()=>{console.warn(i.join("\n"))}}async function cli(t,e,n,s=!0){const i=parseArguments(process.argv.slice(s?2:3),e,n);i===o.InvalidArguments&&process.exit(1);const r=t(i.pluginOptions);i.stdin&&i.stdout?await stdinToStdout(r,i,n):i.stdin?await stdinToFs(r,i,n):i.stdout?await fsToStdout(r,i):await fsToFs(r,i)}!function(t){t.InvalidArguments="INVALID_ARGUMENTS"}(o||(o={}));export{cli,helpTextLogger,parseArguments};
