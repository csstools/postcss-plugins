import{TokenType as e,isToken as n,stringify as t,mirrorVariantType as o}from"@csstools/css-tokenizer";var s;function consumeComponentValue(n,t){const o=t[0];if(o[0]===e.OpenParen||o[0]===e.OpenCurly||o[0]===e.OpenSquare){const e=consumeSimpleBlock(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Function){const e=consumeFunction(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Whitespace){const e=consumeWhitespace(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Comment){const e=consumeComment(n,t);return{advance:e.advance,node:e.node}}return{advance:1,node:new TokenNode(o)}}!function(e){e.Function="function",e.SimpleBlock="simple-block",e.Whitespace="whitespace",e.Comment="comment",e.Token="token"}(s||(s={}));class FunctionNode{type=s.Function;name;endToken;value;constructor(e,n,t){this.name=e,this.endToken=n,this.value=t}nameTokenValue(){return this.name[4].value}tokens(){return this.endToken[0]===e.EOF?[this.name,...this.value.flatMap((e=>n(e)?e:e.tokens()))]:[this.name,...this.value.flatMap((e=>n(e)?e:e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?t(e):e.toString())).join("");return t(this.name)+e+t(this.endToken)}indexOf(e){return this.value.indexOf(e)}at(e){if("number"==typeof e)return e<0&&(e=this.value.length+e),this.value[e]}walk(e){let n=!1;if(this.value.forEach(((t,o)=>{n||(!1!==e({node:t,parent:this},o)?"walk"in t&&!1===t.walk(e)&&(n=!0):n=!0)})),n)return!1}toJSON(){return{type:this.type,name:this.nameTokenValue(),tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isFunctionNode(){return FunctionNode.isFunctionNode(this)}static isFunctionNode(e){return!!e&&(e instanceof FunctionNode&&e.type===s.Function)}}function consumeFunction(n,t){const o=[];let s=1;for(;;){const i=t[s];if(!i||i[0]===e.EOF)return n.onParseError({message:"Unexpected EOF while consuming a function.",start:t[0][2],end:t[t.length-1][3],state:["5.4.9. Consume a function","Unexpected EOF"]}),{advance:t.length,node:new FunctionNode(t[0],i,o)};if(i[0]===e.CloseParen)return{advance:s+1,node:new FunctionNode(t[0],i,o)};if(i[0]===e.Comment||i[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,t.slice(s));s+=e.advance,o.push(...e.nodes);continue}const a=consumeComponentValue(n,t.slice(s));s+=a.advance,o.push(a.node)}}class SimpleBlockNode{type=s.SimpleBlock;startToken;endToken;value;constructor(e,n,t){this.startToken=e,this.endToken=n,this.value=t}tokens(){return this.endToken[0]===e.EOF?[this.startToken,...this.value.flatMap((e=>n(e)?e:e.tokens()))]:[this.startToken,...this.value.flatMap((e=>n(e)?e:e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?t(e):e.toString())).join("");return t(this.startToken)+e+t(this.endToken)}indexOf(e){return this.value.indexOf(e)}at(e){if("number"==typeof e)return e<0&&(e=this.value.length+e),this.value[e]}walk(e){let n=!1;if(this.value.forEach(((t,o)=>{n||(!1!==e({node:t,parent:this},o)?"walk"in t&&!1===t.walk(e)&&(n=!0):n=!0)})),n)return!1}toJSON(){return{type:this.type,startToken:this.startToken,tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isSimpleBlockNode(){return SimpleBlockNode.isSimpleBlockNode(this)}static isSimpleBlockNode(e){return!!e&&(e instanceof SimpleBlockNode&&e.type===s.SimpleBlock)}}function consumeSimpleBlock(n,t){const s=o(t[0][0]);if(!s)throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");const i=[];let a=1;for(;;){const o=t[a];if(!o||o[0]===e.EOF)return n.onParseError({message:"Unexpected EOF while consuming a simple block.",start:t[0][2],end:t[t.length-1][3],state:["5.4.8. Consume a simple block","Unexpected EOF"]}),{advance:t.length,node:new SimpleBlockNode(t[0],o,i)};if(o[0]===s)return{advance:a+1,node:new SimpleBlockNode(t[0],o,i)};if(o[0]===e.Comment||o[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,t.slice(a));a+=e.advance,i.push(...e.nodes);continue}const r=consumeComponentValue(n,t.slice(a));a+=r.advance,i.push(r.node)}}class WhitespaceNode{type=s.Whitespace;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return t(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isWhitespaceNode(){return WhitespaceNode.isWhitespaceNode(this)}static isWhitespaceNode(e){return!!e&&(e instanceof WhitespaceNode&&e.type===s.Whitespace)}}function consumeWhitespace(n,t){let o=0;for(;;){if(t[o][0]!==e.Whitespace)return{advance:o,node:new WhitespaceNode(t.slice(0,o))};o++}}class CommentNode{type=s.Comment;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return t(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isCommentNode(){return CommentNode.isCommentNode(this)}static isCommentNode(e){return!!e&&(e instanceof CommentNode&&e.type===s.Comment)}}function consumeComment(e,n){return{advance:1,node:new CommentNode(n[0])}}function consumeAllCommentsAndWhitespace(n,t){const o=[];let s=0;for(;;)if(t[s][0]!==e.Whitespace){if(t[s][0]!==e.Comment)return{advance:s,nodes:o};o.push(new CommentNode(t[s])),s++}else{const e=consumeWhitespace(0,t.slice(s));s+=e.advance,o.push(e.node)}}class TokenNode{type=s.Token;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return t(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isTokenNode(){return TokenNode.isTokenNode(this)}static isTokenNode(e){return!!e&&(e instanceof TokenNode&&e.type===s.Token)}}function parseComponentValue(n,t){const o={onParseError:(null==t?void 0:t.onParseError)??(()=>{})},s=[...n];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=consumeComponentValue(o,s);if(s[Math.min(i.advance,s.length-1)][0]===e.EOF)return i.node;o.onParseError({message:"Expected EOF after parsing a component value.",start:n[0][2],end:n[n.length-1][3],state:["5.3.9. Parse a component value","Expected EOF"]})}function parseListOfComponentValues(n,t){const o={onParseError:(null==t?void 0:t.onParseError)??(()=>{})},s=[...n];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let a=0;for(;;){if(!s[a]||s[a][0]===e.EOF)return i;const n=consumeComponentValue(o,s.slice(a));i.push(n.node),a+=n.advance}}function parseCommaSeparatedListOfComponentValues(n,t){const o={onParseError:(null==t?void 0:t.onParseError)??(()=>{})},s=[...n];if(0===n.length)return[];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let a=[],r=0;for(;;){if(!s[r]||s[r][0]===e.EOF)return a.length&&i.push(a),i;if(s[r][0]===e.Comma){i.push(a),a=[],r++;continue}const t=consumeComponentValue(o,n.slice(r));a.push(t.node),r+=t.advance}}function gatherNodeAncestry(e){const n=new Map;return e.walk((e=>{Array.isArray(e.node)?e.node.forEach((t=>{n.set(t,e.parent)})):n.set(e.node,e.parent)})),n}function isSimpleBlockNode(e){return SimpleBlockNode.isSimpleBlockNode(e)}function isFunctionNode(e){return FunctionNode.isFunctionNode(e)}function isWhitespaceNode(e){return WhitespaceNode.isWhitespaceNode(e)}function isCommentNode(e){return CommentNode.isCommentNode(e)}function isTokenNode(e){return TokenNode.isTokenNode(e)}export{CommentNode,s as ComponentValueType,FunctionNode,SimpleBlockNode,TokenNode,WhitespaceNode,consumeAllCommentsAndWhitespace,consumeComment,consumeComponentValue,consumeFunction,consumeSimpleBlock,consumeWhitespace,gatherNodeAncestry,isCommentNode,isFunctionNode,isSimpleBlockNode,isTokenNode,isWhitespaceNode,parseCommaSeparatedListOfComponentValues,parseComponentValue,parseListOfComponentValues};
