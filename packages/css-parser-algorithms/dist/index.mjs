import{TokenType as e,isToken as n,stringify as o,mirrorVariantType as t}from"@csstools/css-tokenizer";var s;function consumeComponentValue(n,o){const t=o[0];if(t[0]===e.OpenParen||t[0]===e.OpenCurly||t[0]===e.OpenSquare){const e=consumeSimpleBlock(n,o);return{advance:e.advance,node:e.node}}if(t[0]===e.Function){const e=consumeFunction(n,o);return{advance:e.advance,node:e.node}}if(t[0]===e.Whitespace){const e=consumeWhitespace(n,o);return{advance:e.advance,node:e.node}}if(t[0]===e.Comment){const e=consumeComment(n,o);return{advance:e.advance,node:e.node}}return{advance:1,node:new TokenNode(t)}}!function(e){e.Function="function",e.SimpleBlock="simple-block",e.Whitespace="whitespace",e.Comment="comment",e.Token="token",e.UnclosedFunction="unclosed-function",e.UnclosedSimpleBlock="unclosed-simple-block"}(s||(s={}));class FunctionNode{type=s.Function;name;endToken;value;constructor(e,n,o){this.name=e,this.endToken=n,this.value=o}nameTokenValue(){return this.name[4].value}tokens(){return[this.name,...this.value.flatMap((e=>n(e)?e:e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?o(e):e.toString())).join("");return o(this.name)+e+o(this.endToken)}indexOf(e){return this.value.indexOf(e)}at(e){if("number"==typeof e)return e<0&&(e=this.value.length+e),this.value[e]}walk(e){let n=!1;if(this.value.forEach(((o,t)=>{n||(!1!==e({node:o,parent:this},t)?"walk"in o&&!1===o.walk(e)&&(n=!0):n=!0)})),n)return!1}toJSON(){return{type:this.type,name:this.nameTokenValue(),tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isFunctionNode(){return FunctionNode.isFunctionNode(this)}static isFunctionNode(e){return!!e&&(e instanceof FunctionNode&&e.type===s.Function)}}function consumeFunction(n,o){const t=[];let s=1;for(;;){const i=o[s];if(!i||i[0]===e.EOF)return n.onParseError({message:"Unexpected EOF while consuming a function.",start:o[0][2],end:o[o.length-1][3],state:["5.4.9. Consume a function","Unexpected EOF"]}),{advance:o.length,node:new UnclosedFunctionNode(o)};if(i[0]===e.CloseParen)return{advance:s+1,node:new FunctionNode(o[0],i,t)};if(i[0]===e.Comment||i[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,o.slice(s));s+=e.advance,t.push(...e.nodes);continue}const c=consumeComponentValue(n,o.slice(s));s+=c.advance,t.push(c.node)}}class SimpleBlockNode{type=s.SimpleBlock;startToken;endToken;value;constructor(e,n,o){this.startToken=e,this.endToken=n,this.value=o}tokens(){return[this.startToken,...this.value.flatMap((e=>n(e)?e:e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?o(e):e.toString())).join("");return o(this.startToken)+e+o(this.endToken)}indexOf(e){return this.value.indexOf(e)}at(e){if("number"==typeof e)return e<0&&(e=this.value.length+e),this.value[e]}walk(e){let n=!1;if(this.value.forEach(((o,t)=>{n||(!1!==e({node:o,parent:this},t)?"walk"in o&&!1===o.walk(e)&&(n=!0):n=!0)})),n)return!1}toJSON(){return{type:this.type,startToken:this.startToken,tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isSimpleBlockNode(){return SimpleBlockNode.isSimpleBlockNode(this)}static isSimpleBlockNode(e){return!!e&&(e instanceof SimpleBlockNode&&e.type===s.SimpleBlock)}}function consumeSimpleBlock(n,o){const s=t(o[0][0]);if(!s)throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");const i=[];let c=1;for(;;){const t=o[c];if(!t||t[0]===e.EOF)return n.onParseError({message:"Unexpected EOF while consuming a simple block.",start:o[0][2],end:o[o.length-1][3],state:["5.4.8. Consume a simple block","Unexpected EOF"]}),{advance:o.length,node:new UnclosedSimpleBlockNode(o)};if(t[0]===s)return{advance:c+1,node:new SimpleBlockNode(o[0],t,i)};if(t[0]===e.Comment||t[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,o.slice(c));c+=e.advance,i.push(...e.nodes);continue}const r=consumeComponentValue(n,o.slice(c));c+=r.advance,i.push(r.node)}}class WhitespaceNode{type=s.Whitespace;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return o(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isWhitespaceNode(){return WhitespaceNode.isWhitespaceNode(this)}static isWhitespaceNode(e){return!!e&&(e instanceof WhitespaceNode&&e.type===s.Whitespace)}}function consumeWhitespace(n,o){let t=0;for(;;){if(o[t][0]!==e.Whitespace)return{advance:t,node:new WhitespaceNode(o.slice(0,t))};t++}}class CommentNode{type=s.Comment;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return o(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isCommentNode(){return CommentNode.isCommentNode(this)}static isCommentNode(e){return!!e&&(e instanceof CommentNode&&e.type===s.Comment)}}function consumeComment(e,n){return{advance:1,node:new CommentNode(n[0])}}function consumeAllCommentsAndWhitespace(n,o){const t=[];let s=0;for(;;)if(o[s][0]!==e.Whitespace){if(o[s][0]!==e.Comment)return{advance:s,nodes:t};t.push(new CommentNode(o[s])),s++}else{const e=consumeWhitespace(0,o.slice(s));s+=e.advance,t.push(e.node)}}class TokenNode{type=s.Token;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return o(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isTokenNode(){return TokenNode.isTokenNode(this)}static isTokenNode(e){return!!e&&(e instanceof TokenNode&&e.type===s.Token)}}class UnclosedFunctionNode{type=s.UnclosedFunction;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return o(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isUnclosedFunctionNode(){return UnclosedFunctionNode.isUnclosedFunctionNode(this)}static isUnclosedFunctionNode(e){return!!e&&(e instanceof UnclosedFunctionNode&&e.type===s.UnclosedFunction)}}class UnclosedSimpleBlockNode{type=s.UnclosedSimpleBlock;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return o(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isUnclosedSimpleBlockNode(){return UnclosedSimpleBlockNode.isUnclosedSimpleBlockNode(this)}static isUnclosedSimpleBlockNode(e){return!!e&&(e instanceof UnclosedSimpleBlockNode&&e.type===s.UnclosedSimpleBlock)}}function parseComponentValue(n,o){const t={onParseError:(null==o?void 0:o.onParseError)??(()=>{})},s=[...n];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=consumeComponentValue(t,s);if(s[Math.min(i.advance,s.length-1)][0]===e.EOF)return i.node;t.onParseError({message:"Expected EOF after parsing a component value.",start:n[0][2],end:n[n.length-1][3],state:["5.3.9. Parse a component value","Expected EOF"]})}function parseListOfComponentValues(n,o){const t={onParseError:(null==o?void 0:o.onParseError)??(()=>{})},s=[...n];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let c=0;for(;;){if(!s[c]||s[c][0]===e.EOF)return i;const n=consumeComponentValue(t,s.slice(c));i.push(n.node),c+=n.advance}}function parseCommaSeparatedListOfComponentValues(n,o){const t={onParseError:(null==o?void 0:o.onParseError)??(()=>{})},s=[...n];if(0===n.length)return[];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let c=[],r=0;for(;;){if(!s[r]||s[r][0]===e.EOF)return c.length&&i.push(c),i;if(s[r][0]===e.Comma){i.push(c),c=[],r++;continue}const o=consumeComponentValue(t,n.slice(r));c.push(o.node),r+=o.advance}}function gatherNodeAncestry(e){const n=new Map;return e.walk((e=>{Array.isArray(e.node)?e.node.forEach((o=>{n.set(o,e.parent)})):n.set(e.node,e.parent)})),n}function isSimpleBlockNode(e){return SimpleBlockNode.isSimpleBlockNode(e)}function isFunctionNode(e){return FunctionNode.isFunctionNode(e)}function isUnclosedSimpleBlockNode(e){return UnclosedSimpleBlockNode.isUnclosedSimpleBlockNode(e)}function isUnclosedFunctionNode(e){return UnclosedFunctionNode.isUnclosedFunctionNode(e)}function isWhitespaceNode(e){return WhitespaceNode.isWhitespaceNode(e)}function isCommentNode(e){return CommentNode.isCommentNode(e)}function isTokenNode(e){return TokenNode.isTokenNode(e)}export{CommentNode,s as ComponentValueType,FunctionNode,SimpleBlockNode,TokenNode,UnclosedFunctionNode,UnclosedSimpleBlockNode,WhitespaceNode,consumeAllCommentsAndWhitespace,consumeComment,consumeComponentValue,consumeFunction,consumeSimpleBlock,consumeWhitespace,gatherNodeAncestry,isCommentNode,isFunctionNode,isSimpleBlockNode,isTokenNode,isUnclosedFunctionNode,isUnclosedSimpleBlockNode,isWhitespaceNode,parseCommaSeparatedListOfComponentValues,parseComponentValue,parseListOfComponentValues};
