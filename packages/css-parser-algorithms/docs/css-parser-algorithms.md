<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@csstools/css-parser-algorithms](./css-parser-algorithms.md)

## css-parser-algorithms package

Parse CSS following the [CSS Syntax Level 3 specification](https://drafts.csswg.org/css-syntax/#parsing)<!-- -->.

## Remarks

The tokenizing and parsing tools provided by CSS Tools are designed to be low level and generic with strong ties to their respective specifications.

Any analysis or mutation of CSS source code should be done with the least powerful tool that can accomplish the task. For many applications it is sufficient to work with tokens. For others you might need to use [@csstools/css-parser-algorithms](https://github.com/csstools/postcss-plugins/tree/main/packages/css-parser-algorithms) or a more specific parser.

The implementation of the AST nodes is kept lightweight and simple. Do not expect magic methods, instead assume that arrays and class instances behave like any other JavaScript.

## Example 1

Parse a string of CSS into a component value:

```js
import { tokenize } from '@csstools/css-tokenizer';
import { parseComponentValue } from '@csstools/css-parser-algorithms';

const myCSS = `calc(1px * 2)`;

const componentValue = parseComponentValue(tokenize({
	css: myCSS,
}));

console.log(componentValue);
```

## Example 2

Use the right algorithm for the job.

Algorithms that can parse larger structures (comma-separated lists, ...) can also parse smaller structures. However, the opposite is not true.

If your context allows a list of component values, use [parseListOfComponentValues()](./css-parser-algorithms.parselistofcomponentvalues.md)<!-- -->:

```js
import { tokenize } from '@csstools/css-tokenizer';
import { parseListOfComponentValues } from '@csstools/css-parser-algorithms';

parseListOfComponentValues(tokenize({ css: `10x 20px` }));
```
If your context allows a comma-separated list of component values, use [parseCommaSeparatedListOfComponentValues()](./css-parser-algorithms.parsecommaseparatedlistofcomponentvalues.md)<!-- -->:

```js
import { tokenize } from '@csstools/css-tokenizer';
import { parseCommaSeparatedListOfComponentValues } from '@csstools/css-parser-algorithms';

parseCommaSeparatedListOfComponentValues(tokenize({ css: `20deg, 50%, 30%` }));
```

## Example 3

Use the stateful walkers to keep track of the context of a given component value.

```js
import { tokenize } from '@csstools/css-tokenizer';
import { parseComponentValue, isSimpleBlockNode } from '@csstools/css-parser-algorithms';

const myCSS = `calc(1px * (5 / 2))`;

const componentValue = parseComponentValue(tokenize({ css: myCSS }));

let state = { inSimpleBlock: false };
componentValue.walk((entry) => {
	if (isSimpleBlockNode(entry)) {
		entry.state.inSimpleBlock = true;
		return;
	}

	if (entry.state.inSimpleBlock) {
		console.log(entry.node.toString()); // `5`, ...
	}
}, state);
```

## Classes

<table><thead><tr><th>

Class


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[CommentNode](./css-parser-algorithms.commentnode.md)


</td><td>


</td></tr>
<tr><td>

[FunctionNode](./css-parser-algorithms.functionnode.md)


</td><td>

A function node.


</td></tr>
<tr><td>

[SimpleBlockNode](./css-parser-algorithms.simpleblocknode.md)


</td><td>

A simple block node.


</td></tr>
<tr><td>

[TokenNode](./css-parser-algorithms.tokennode.md)


</td><td>


</td></tr>
<tr><td>

[WhitespaceNode](./css-parser-algorithms.whitespacenode.md)


</td><td>


</td></tr>
</tbody></table>

## Abstract Classes

<table><thead><tr><th>

Abstract Class


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ContainerNodeBaseClass](./css-parser-algorithms.containernodebaseclass.md)


</td><td>


</td></tr>
</tbody></table>

## Enumerations

<table><thead><tr><th>

Enumeration


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ComponentValueType](./css-parser-algorithms.componentvaluetype.md)


</td><td>


</td></tr>
</tbody></table>

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[forEach(componentValues, cb, state)](./css-parser-algorithms.foreach.md)


</td><td>

Iterates over each item in a list of component values.


</td></tr>
<tr><td>

[gatherNodeAncestry(node)](./css-parser-algorithms.gathernodeancestry.md)


</td><td>

AST nodes do not have a `parent` property or method. This makes it harder to traverse the AST upwards. This function builds a `Map<Child, Parent>` that can be used to lookup ancestors of a node.


</td></tr>
<tr><td>

[isCommentNode(x)](./css-parser-algorithms.iscommentnode.md)


</td><td>

Check if the current object is a `CommentNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[isFunctionNode(x)](./css-parser-algorithms.isfunctionnode.md)


</td><td>

Check if the current object is a `FunctionNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[isSimpleBlockNode(x)](./css-parser-algorithms.issimpleblocknode.md)


</td><td>

Check if the current object is a `SimpleBlockNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[isTokenNode(x)](./css-parser-algorithms.istokennode.md)


</td><td>

Check if the current object is a `TokenNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[isWhitespaceNode(x)](./css-parser-algorithms.iswhitespacenode.md)


</td><td>

Check if the current object is a `WhitespaceNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[isWhiteSpaceOrCommentNode(x)](./css-parser-algorithms.iswhitespaceorcommentnode.md)


</td><td>

Check if the current object is a `WhiteSpaceNode` or a `CommentNode`<!-- -->. This is a type guard.


</td></tr>
<tr><td>

[parseCommaSeparatedListOfComponentValues(tokens, options)](./css-parser-algorithms.parsecommaseparatedlistofcomponentvalues.md)


</td><td>

Parse a comma-separated list of component values.


</td></tr>
<tr><td>

[parseComponentValue(tokens, options)](./css-parser-algorithms.parsecomponentvalue.md)


</td><td>

Parse a single component value.


</td></tr>
<tr><td>

[parseListOfComponentValues(tokens, options)](./css-parser-algorithms.parselistofcomponentvalues.md)


</td><td>

Parse a list of component values.


</td></tr>
<tr><td>

[replaceComponentValues(componentValuesList, replaceWith)](./css-parser-algorithms.replacecomponentvalues.md)


</td><td>

Replace specific component values in a list of component values. A helper for the most common and simplistic cases when mutating an AST.


</td></tr>
<tr><td>

[sourceIndices(x)](./css-parser-algorithms.sourceindices.md)


</td><td>

Returns the start and end index of a node in the CSS source string.


</td></tr>
<tr><td>

[stringify(componentValueLists)](./css-parser-algorithms.stringify.md)


</td><td>

Concatenate the string representation of a collection of component values. This is not a proper serializer that will handle escaping and whitespace. It only produces valid CSS for token lists that are also valid.


</td></tr>
<tr><td>

[walk(componentValues, cb, state)](./css-parser-algorithms.walk.md)


</td><td>

Walks each item in a list of component values all of their children.


</td></tr>
<tr><td>

[walkerIndexGenerator(initialList)](./css-parser-algorithms.walkerindexgenerator.md)


</td><td>

Generate a function that finds the next element that should be visited when walking an AST. Rules : 1. the previous iteration is used as a reference, so any checks are relative to the start of the current iteration. 2. the next element always appears after the current index. 3. the next element always exists in the list. 4. replacing an element does not cause the replaced element to be visited. 5. removing an element does not cause elements to be skipped. 6. an element added later in the list will be visited.


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ComponentValue](./css-parser-algorithms.componentvalue.md)


</td><td>


</td></tr>
<tr><td>

[ContainerNode](./css-parser-algorithms.containernode.md)


</td><td>


</td></tr>
</tbody></table>

