"use strict";var e=require("postcss-value-parser"),r=require("@csstools/cascade-layer-name-parser");const t=r.parse("csstools-implicit-layer")[0];function collectCascadeLayerOrder(e){const o=new Map,n=new Map,s=[];e.walkAtRules((e=>{var a;if("layer"!==e.name.toLowerCase())return;{let r=e.parent;for(;r;){if("atrule"!==r.type||"layer"!==r.name.toLowerCase()){if(r===e.root())break;return}r=r.parent}}let i;if(e.nodes)i=normalizeLayerName(e.params,1);else{if(!e.params.trim())return;i=e.params}let l=r.parse(i);if(null!=(a=l)&&a.length){{let r=e.parent;for(;r&&"atrule"===r.type&&"layer"===r.name.toLowerCase();){const e=n.get(r);e?(l=l.map((r=>e.concat(r))),r=r.parent):r=r.parent}}if(r.addLayerToModel(s,l),e.nodes){const r=l[0].concat(t);o.set(e,r),n.set(e,l[0])}}}));for(const e of o.values())r.addLayerToModel(s,[e]);const a=new WeakMap;for(const[e,r]of o)a.set(e,s.findIndex((e=>r.equal(e))));return a}function cascadeLayerNumberForNode(e,r){return e.parent&&"atrule"===e.parent.type&&"layer"===e.parent.name.toLowerCase()?r.has(e.parent)?r.get(e.parent):-1:1/0}function normalizeLayerName(e,r){return e.trim()?e:"csstools-anon-layer--"+r++}const o=/(!\s*)?postcss-custom-properties:\s*off\b/i,n=new WeakMap;function isBlockIgnored(e){if(!e||!e.nodes)return!1;if(n.has(e))return n.get(e);const r=e.some((e=>isIgnoreComment(e,o)));return n.set(e,r),r}const s=/(!\s*)?postcss-custom-properties:\s*ignore\s+next\b/i;function isDeclarationIgnored(e){return!!e&&(!!isBlockIgnored(e.parent)||isIgnoreComment(e.prev(),s))}function isIgnoreComment(e,r){return e&&"comment"===e.type&&r.test(e.text)}const a=new Set(["layer"]);function isProcessableRule(e){if(!isHtmlRule(e)&&!isRootRule(e))return!1;let r=e.parent;for(;r;){if("atrule"===r.type&&!a.has(r.name.toLowerCase()))return!1;r=r.parent}return!0}const i=/^html$/i,l=/^:root$/i;function isHtmlRule(e){return e.selectors.some((e=>i.test(e)))&&e.nodes&&e.nodes.length}function isRootRule(e){return e.selectors.some((e=>l.test(e)))&&e.nodes&&e.nodes.length}const c=/^var$/i;function isVarFunction(e){return"function"===e.type&&c.test(e.value)&&Object(e.nodes).length>0}function removeCyclicReferences(e,r){const t=new Set;let o=r;for(;e.size>0;)try{toposort(Array.from(e.keys()),o);break}catch(r){if(!r._graphNode)throw r;e.delete(r._graphNode),t.add(r._graphNode),o=o.filter((e=>-1===e.indexOf(r._graphNode)))}return t}function toposort(e,r){let t=e.length;const o=new Array(t),n={};let s=t;const a=makeOutgoingEdges(r),i=makeNodesHash(e);for(;s--;)n[s]||visit(e[s],s,new Set);return o;function visit(e,r,s){if(s.has(e)){const r=new Error("Cyclic dependency"+JSON.stringify(e));throw r._graphNode=e,r}if(!i.has(e))return;if(n[r])return;n[r]=!0;let l=a.get(e)||new Set;if(l=Array.from(l),r=l.length){s.add(e);do{const e=l[--r];visit(e,i.get(e),s)}while(r);s.delete(e)}o[--t]=e}}function makeOutgoingEdges(e){const r=new Map;for(let t=0,o=e.length;t<o;t++){const o=e[t];r.has(o[0])||r.set(o[0],new Set),r.has(o[1])||r.set(o[1],new Set),r.get(o[0]).add(o[1])}return r}function makeNodesHash(e){const r=new Map;for(let t=0,o=e.length;t<o;t++)r.set(e[t],t);return r}function getCustomPropertiesFromRoot(r){const t=new Map,o=new Map,n=new Map,s=new Map,a=new Map,i=collectCascadeLayerOrder(r);r.walkRules((e=>{isProcessableRule(e)&&(isBlockIgnored(e)||(isHtmlRule(e)?e.each((e=>{if("decl"!==e.type)return;if(!e.variable||isDeclarationIgnored(e))return;if("initial"===e.value.toLowerCase().trim())return;const r=cascadeLayerNumberForNode(e,i);r>=(s.get(e.prop)??-1)&&(s.set(e.prop,r),t.set(e.prop,e.value))})):isRootRule(e)&&e.each((e=>{if("decl"!==e.type)return;if(!e.variable||isDeclarationIgnored(e))return;if("initial"===e.value.toLowerCase().trim())return;const r=cascadeLayerNumberForNode(e,i);r>=(a.get(e.prop)??-1)&&(a.set(e.prop,r),o.set(e.prop,e.value))}))))}));for(const[e,r]of t.entries())n.set(e,r);for(const[e,r]of o.entries())n.set(e,r);const l=[],c=new Map;for(const[r,t]of n.entries()){const o=e(t);e.walk(o.nodes,(e=>{if(isVarFunction(e)){const[t]=e.nodes.filter((e=>"word"===e.type));l.push([t.value,r])}})),c.set(r,e(t))}return removeCyclicReferences(c,l),c}function transformValueAST(r,t){if(r.nodes&&r.nodes.length){const o=new Map;r.nodes.forEach((e=>{o.set(e,r)})),e.walk(r.nodes,(e=>{"nodes"in e&&e.nodes.length&&e.nodes.forEach((r=>{o.set(r,e)}))})),e.walk(r.nodes,(r=>{if(!isVarFunction(r))return;const[n,...s]=r.nodes.filter((e=>"div"!==e.type)),{value:a}=n,i=o.get(r),l=i.nodes.indexOf(r);if(-1===l)return;let c=!1;s&&e.walk(s,(e=>{if(isVarFunction(e)){const[r]=e.nodes.filter((e=>"word"===e.type));if(t.has(r.value))return;return c=!0,!1}}));let u=[];if(t.has(a))u=t.get(a).nodes;else{if(!s.length||c)return;u=r.nodes.slice(r.nodes.indexOf(s[0]))}u.length?i.nodes.splice(l,1,...u):i.nodes.splice(l,1,{type:"comment",value:"",sourceIndex:r.sourceIndex,sourceEndIndex:r.sourceEndIndex})}),!0)}return r.toString()}var transformProperties=(r,t,o)=>{if(isTransformableDecl(r)&&!isDeclarationIgnored(r)){const n=r.value;let s=transformValueAST(e(n),t);const a=new Set;for(;s.includes("--")&&s.toLowerCase().includes("var(")&&!a.has(s);){a.add(s);s=transformValueAST(e(s),t)}if(s!==n){if(parentHasExactFallback(r,s))return void(o.preserve||r.remove());if(o.preserve){const e=r.cloneBefore({value:s});hasTrailingComment(e)&&(e.raws.value.value=e.value.replace(u,"$1"),e.raws.value.raw=e.raws.value.value+e.raws.value.raw.replace(u,"$2"))}else r.value=s,hasTrailingComment(r)&&(r.raws.value.value=r.value.replace(u,"$1"),r.raws.value.raw=r.raws.value.value+r.raws.value.raw.replace(u,"$2"))}}};const isTransformableDecl=e=>!e.variable&&e.value.includes("--")&&e.value.toLowerCase().includes("var("),hasTrailingComment=e=>"value"in Object(Object(e.raws).value)&&"raw"in e.raws.value&&u.test(e.raws.value.raw),u=/^([\W\w]+)(\s*\/\*[\W\w]+?\*\/)$/;function parentHasExactFallback(e,r){if(!e||!e.parent)return!1;let t=!1;const o=e.parent.index(e);return e.parent.each(((n,s)=>n!==e&&(!(s>=o)&&void("decl"===n.type&&n.prop.toLowerCase()===e.prop.toLowerCase()&&n.value===r&&(t=!0))))),t}const creator=r=>{const t=!("preserve"in Object(r))||Boolean(r.preserve);if("importFrom"in Object(r))throw new Error('[postcss-custom-properties] "importFrom" is no longer supported');if("exportTo"in Object(r))throw new Error('[postcss-custom-properties] "exportTo" is no longer supported');return{postcssPlugin:"postcss-custom-properties",prepare:()=>{let r=new Map;return{Once:e=>{r=getCustomPropertiesFromRoot(e)},Declaration:o=>{let n=r;if(t&&o.parent){let t=!1;o.parent.each((s=>{o!==s&&"decl"===s.type&&s.variable&&!isDeclarationIgnored(s)&&(t||(n=new Map(r),t=!0),"initial"!==s.value.toLowerCase().trim()?n.set(s.prop,e(s.value)):n.delete(s.prop))}))}transformProperties(o,n,{preserve:t})}}}}};creator.postcss=!0,module.exports=creator;
