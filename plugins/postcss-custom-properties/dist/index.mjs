import e from"postcss-value-parser";import{parse as t,addLayerToModel as r}from"@csstools/cascade-layer-name-parser";const n=t("csstools-implicit-layer")[0];function collectCascadeLayerOrder(e){const o=new Map,s=new Map,a=[];e.walkAtRules((e=>{var l;if("layer"!==e.name.toLowerCase())return;{let t=e.parent;for(;t;){if("atrule"!==t.type||"layer"!==t.name.toLowerCase()){if(t===e.root())break;return}t=t.parent}}let i;if(e.nodes)i=normalizeLayerName(e.params,1);else{if(!e.params.trim())return;i=e.params}let c=t(i);if(null!=(l=c)&&l.length){{let t=e.parent;for(;t&&"atrule"===t.type&&"layer"===t.name.toLowerCase();){const e=s.get(t);e?(c=c.map((t=>e.concat(t))),t=t.parent):t=t.parent}}if(r(a,c),e.nodes){const t=c[0].concat(n);o.set(e,t),s.set(e,c[0])}}}));for(const e of o.values())r(a,[e]);const l=new WeakMap;for(const[e,t]of o)l.set(e,a.findIndex((e=>t.equal(e))));return l}function normalizeLayerName(e,t){return e.trim()?e:"csstools-anon-layer--"+t++}const o=/(!\s*)?postcss-custom-properties:\s*off\b/i,s=new WeakMap;function isBlockIgnored(e){if(!e||!e.nodes)return!1;if(s.has(e))return s.get(e);const t=e.some((e=>isIgnoreComment(e,o)));return s.set(e,t),t}const a=/(!\s*)?postcss-custom-properties:\s*ignore\s+next\b/i;function isDeclarationIgnored(e){return!!e&&(!!isBlockIgnored(e.parent)||isIgnoreComment(e.prev(),a))}function isIgnoreComment(e,t){return!!e&&"comment"===e.type&&t.test(e.text)}const l=new Set(["layer"]);function isProcessableRule(e){let t=e.parent;for(;t;){if("atrule"===t.type&&!l.has(t.name.toLowerCase()))return!1;t=t.parent}return!0}const i=/^html$/i,c=/^:where\(html\)$/i,u=/^:root$/i,p=/^:where\(:root\)$/i,f=/(html|:root)/i,d=/^var$/i;function isVarFunction(e){return"function"===e.type&&d.test(e.value)&&Object(e.nodes).length>0}function removeCyclicReferences(e,t){const r=new Set;let n=t;for(;e.size>0;)try{toposort(Array.from(e.keys()),n);break}catch(t){if(!t._graphNode)throw t;e.delete(t._graphNode),r.add(t._graphNode),n=n.filter((e=>-1===e.indexOf(t._graphNode)))}return r}function toposort(e,t){let r=e.length;const n=new Array(r),o={};let s=r;const a=makeOutgoingEdges(t),l=makeNodesHash(e);for(;s--;)o[s]||visit(e[s],s,new Set);return n;function visit(e,t,s){if(s.has(e)){const t=new Error("Cyclic dependency"+JSON.stringify(e));throw t._graphNode=e,t}if(!l.has(e))return;if(o[t])return;o[t]=!0;let i=a.get(e)||new Set;if(i=Array.from(i),t=i.length){s.add(e);do{const e=i[--t];visit(e,l.get(e),s)}while(t);s.delete(e)}n[--r]=e}}function makeOutgoingEdges(e){const t=new Map;for(let r=0,n=e.length;r<n;r++){const n=e[r];t.has(n[0])||t.set(n[0],new Set),t.has(n[1])||t.set(n[1],new Set),t.get(n[0]).add(n[1])}return t}function makeNodesHash(e){const t=new Map;for(let r=0,n=e.length;r<n;r++)t.set(e[r],r);return t}function getCustomPropertiesFromRoot(t){const r=new Map,n=new Map,o=collectCascadeLayerOrder(t);t.walkRules((e=>{var t;f.test(e.selector)&&null!=(t=e.nodes)&&t.length&&isProcessableRule(e)&&(isBlockIgnored(e)||e.selectors.forEach((t=>{let s=-1;if(c.test(t)||p.test(t))s=0;else if(i.test(t))s=1;else{if(!u.test(t))return;s=2}const a=(f=o,((l=e).parent&&"atrule"===l.parent.type&&"layer"===l.parent.name.toLowerCase()?f.has(l.parent)?f.get(l.parent)+1:0:1e7)+10+s);var l,f;e.each((e=>{if("decl"!==e.type)return;if(!e.variable||isDeclarationIgnored(e))return;if("initial"===e.value.toLowerCase().trim())return;const t=n.get(e.prop)??-1;a>=t&&(n.set(e.prop,a),r.set(e.prop,e.value))}))})))}));const s=[],a=new Map;for(const[t,n]of r.entries()){const r=e(n);e.walk(r.nodes,(e=>{if(isVarFunction(e)){const[r]=e.nodes.filter((e=>"word"===e.type));s.push([r.value,t])}})),a.set(t,e(n))}return removeCyclicReferences(a,s),a}function transformValueAST(t,r){if(t.nodes&&t.nodes.length){const n=new Map;t.nodes.forEach((e=>{n.set(e,t)})),e.walk(t.nodes,(e=>{"nodes"in e&&e.nodes.length&&e.nodes.forEach((t=>{n.set(t,e)}))})),e.walk(t.nodes,(t=>{if(!isVarFunction(t))return;const[o,...s]=t.nodes.filter((e=>"div"!==e.type)),{value:a}=o,l=n.get(t);if(!l)return;const i=l.nodes.indexOf(t);if(-1===i)return;let c=!1;s&&e.walk(s,(e=>{if(isVarFunction(e)){const[t]=e.nodes.filter((e=>"word"===e.type));if(r.has(t.value))return;return c=!0,!1}}));let u=[];if(r.has(a)){var p;u=(null==(p=r.get(a))?void 0:p.nodes)??[]}else{if(!s.length||c)return;u=t.nodes.slice(t.nodes.indexOf(s[0]))}u.length?(l.nodes.splice(i,1,...u),l.nodes.forEach((e=>n.set(e,l)))):(l.nodes.splice(i,1,{type:"comment",value:"",sourceIndex:t.sourceIndex,sourceEndIndex:t.sourceEndIndex}),l.nodes.forEach((e=>n.set(e,l))))}),!0)}return t.toString()}var transformProperties=(t,r,n)=>{if(isTransformableDecl(t)&&!isDeclarationIgnored(t)){const a=t.value;let l=transformValueAST(e(a),r);const i=new Set;for(;l.includes("--")&&l.toLowerCase().includes("var(")&&!i.has(l);){i.add(l);l=transformValueAST(e(l),r)}if(l!==a){if(parentHasExactFallback(t,l))return void(n.preserve||t.remove());if(n.preserve){var o;const e=t.cloneBefore({value:l});hasTrailingComment(e)&&null!=(o=e.raws)&&o.value&&(e.raws.value.value=e.value.replace(v,"$1"),e.raws.value.raw=e.raws.value.value+e.raws.value.raw.replace(v,"$2"))}else{var s;t.value=l,hasTrailingComment(t)&&null!=(s=t.raws)&&s.value&&(t.raws.value.value=t.value.replace(v,"$1"),t.raws.value.raw=t.raws.value.value+t.raws.value.raw.replace(v,"$2"))}}}};const isTransformableDecl=e=>!e.variable&&e.value.includes("--")&&e.value.toLowerCase().includes("var("),hasTrailingComment=e=>{var t,r;return"value"in Object(Object(e.raws).value)&&"raw"in((null==(t=e.raws)?void 0:t.value)??{})&&v.test((null==(r=e.raws.value)?void 0:r.raw)??"")},v=/^([\W\w]+)(\s*\/\*[\W\w]+?\*\/)$/;function parentHasExactFallback(e,t){if(!e||!e.parent)return!1;let r=!1;const n=e.parent.index(e);return e.parent.each(((o,s)=>o!==e&&(!(s>=n)&&void("decl"===o.type&&o.prop.toLowerCase()===e.prop.toLowerCase()&&o.value===t&&(r=!0))))),r}function hasSupportsAtRuleAncestor(e){let t=e.parent;for(;t;)if("atrule"===t.type){if("supports"===t.name.toLowerCase()&&/([^\w]var\()|(\(top: var\(--f\))/i.test(t.params))return!0;t=t.parent}else t=t.parent;return!1}const creator=t=>{const r=!("preserve"in Object(t))||Boolean(null==t?void 0:t.preserve);if("importFrom"in Object(t))throw new Error('[postcss-custom-properties] "importFrom" is no longer supported');if("exportTo"in Object(t))throw new Error('[postcss-custom-properties] "exportTo" is no longer supported');return{postcssPlugin:"postcss-custom-properties",prepare:()=>{let t=new Map;return{Once:e=>{t=getCustomPropertiesFromRoot(e)},Declaration:n=>{if(hasSupportsAtRuleAncestor(n))return;let o=t;if(r&&n.parent){let r=!1;n.parent.each((s=>{n!==s&&"decl"===s.type&&s.variable&&!isDeclarationIgnored(s)&&(r||(o=new Map(t),r=!0),"initial"!==s.value.toLowerCase().trim()?o.set(s.prop,e(s.value)):o.delete(s.prop))}))}transformProperties(n,o,{preserve:r})}}}}};creator.postcss=!0;export{creator as default};
