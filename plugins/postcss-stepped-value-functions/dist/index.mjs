import e from"postcss-value-parser";function isVarNode(e){return"function"===e.type&&"var"===e.value.toLowerCase()}function validateArgumentsAndTypes(n,t,o,r){const a=[];let u=!1;if(n.nodes.forEach((e=>{"word"!==e.type?isVarNode(e)&&(u=!0):a.push(e)})),u)return void optionallyWarn(t,o,`Failed to transform ${t.value} as variables can't be processed.`,r);if(2!==a.length)return void optionallyWarn(t,o,`Failed to transform ${t.value} as it's expecting 2 arguments instead of ${a.length}`,r);const s=e.unit(a[0].value),i=e.unit(a[1].value);if(s&&i){if(s.unit===i.unit)return[s,i];optionallyWarn(t,o,`Failed to transform ${t.value} as the units don't match`,r)}}function optionallyWarn(e,n,t,o){"warn"===o.onInvalid&&e.warn(n,t)}function functionNodeToWordNode(e){delete e.nodes;const n=e;return n.type="word",n}const n="mod(";function transformModFunction(n,t,o){const r=e(n.value);return r.walk((e=>{if("function"!==e.type||"mod"!==e.value.toLowerCase())return;const r=validateArgumentsAndTypes(e,n,t,o);if(!r)return;const[a,u]=r,s=Number(a.number),i=Number(u.number),l=(s%i+i)%i;if("number"!=typeof l||isNaN(l))return;functionNodeToWordNode(e).value=0===l?"0":`${l}${a.unit}`}),!0),r.toString()}const t="rem(";function transformRemFunction(n,t,o){const r=e(n.value);return r.walk((e=>{if("function"!==e.type||"rem"!==e.value.toLowerCase())return;const r=validateArgumentsAndTypes(e,n,t,o);if(!r)return;const[a,u]=r,s=Number(a.number)%Number(u.number);if("number"!=typeof s&&!isNaN(s))return;functionNodeToWordNode(e).value=0===s?"0":`${s}${a.unit}`}),!0),r.toString()}const o="round(";var r;!function(e){e.Nearest="nearest",e.Up="up",e.Down="down",e.ToZero="to-zero"}(r||(r={}));const a=/^[a-z|-]+$/i;function transformRoundFunction(n,t,o){const u=e(n.value);return u.walk((u=>{if("function"!==u.type||"round"!==u.value.toLowerCase())return;if(3!==u.nodes.length&&5!==u.nodes.length)return void optionallyWarn(n,t,`Failed to transform ${n.value} as the amount of arguments isn't valid`,o);const s=u.nodes.filter((e=>"word"===e.type)),i=s[0].value;let l,c,d;if(a.test(i.toLowerCase())){var f,v;if(!Object.values(r).includes(i.toLowerCase()))return void optionallyWarn(n,t,`Failed to transform ${n.value} as ${i} is not a valid rounding strategy.`,o);l=i.toLowerCase(),c=e.unit((null==s||null==(f=s[1])?void 0:f.value)||""),d=e.unit((null==s||null==(v=s[2])?void 0:v.value)||"")}else{var m,p;l=r.Nearest,c=e.unit((null==s||null==(m=s[0])?void 0:m.value)||""),d=e.unit((null==s||null==(p=s[1])?void 0:p.value)||"")}if(!c||!d)return;if(c.unit!==d.unit)return void optionallyWarn(n,t,`Failed to transform ${n.value} as the units don't match`,o);const N=Number(c.number),b=Number(d.number);let w;switch(l){case r.Down:w=Math.floor(N/b)*b;break;case r.Up:w=Math.ceil(N/b)*b;break;case r.ToZero:w=Math.trunc(N/b)*b;break;case r.Nearest:default:w=Math.round(N/b)*b}if("number"!=typeof w||isNaN(w))return;functionNodeToWordNode(u).value=0===w?"0":`${w}${c.unit}`}),!0),u.toString()}const creator=e=>{const r=Object.assign({preserve:!1,onInvalid:""},e);return{postcssPlugin:"postcss-stepped-value-functions",Declaration(e,{result:a}){const u=[n,t,o].some((n=>e.value.toLowerCase().includes(n)));if(!e||!u)return;const s=e.clone();if(s.value.toLowerCase().includes(n)){const e=transformModFunction(s,a,r);e&&(s.value=e)}if(s.value.toLowerCase().includes(t)){const e=transformRemFunction(s,a,r);e&&(s.value=e)}if(s.value.toLowerCase().includes(o)){const e=transformRoundFunction(s,a,r);e&&(s.value=e)}e.value!==s.value&&(e.before(s),r.preserve||e.remove())}}};creator.postcss=!0;export{creator as default};
