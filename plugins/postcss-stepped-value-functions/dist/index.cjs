"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var t=e(require("postcss-value-parser"));function n(e,n,o,r){const a=[];let s=!1;if(e.nodes.forEach((e=>{"word"!==e.type?function(e){return"function"===e.type&&"var"===e.value.toLowerCase()}(e)&&(s=!0):a.push(e)})),s)return void u(n,o,`Failed to transform ${n.value} as variables can't be processed.`,r);if(2!==a.length)return void u(n,o,`Failed to transform ${n.value} as it's expecting 2 arguments instead of ${a.length}`,r);const l=t.default.unit(a[0].value),i=t.default.unit(a[1].value);if(l&&i){if(l.unit===i.unit)return[l,i];u(n,o,`Failed to transform ${n.value} as the units don't match`,r)}}function u(e,t,n,u){"warn"===u.onInvalid&&e.warn(t,n)}function o(e){delete e.nodes;const t=e;return t.type="word",t}const r="mod(";const a="rem(";const s="round(";var l;!function(e){e.Nearest="nearest",e.Up="up",e.Down="down",e.ToZero="to-zero"}(l||(l={}));const i=/^[a-z|-]+$/i;const c=e=>{const c=Object.assign({preserve:!1,onInvalid:""},e);return{postcssPlugin:"postcss-stepped-value-functions",Declaration(e,{result:f}){const d=[r,a,s].some((t=>e.value.toLowerCase().includes(t)));if(!e||!d)return;const v=e.clone();if(v.value.toLowerCase().includes(r)){const e=function(e,u,r){const a=t.default(e.value);return a.walk((t=>{if("function"!==t.type||"mod"!==t.value.toLowerCase())return;const a=n(t,e,u,r);if(!a)return;const[s,l]=a,i=Number(s.number),c=Number(l.number),f=(i%c+c)%c;"number"!=typeof f||isNaN(f)||(o(t).value=0===f?"0":`${f}${s.unit}`)}),!0),a.toString()}(v,f,c);e&&(v.value=e)}if(v.value.toLowerCase().includes(a)){const e=function(e,u,r){const a=t.default(e.value);return a.walk((t=>{if("function"!==t.type||"rem"!==t.value.toLowerCase())return;const a=n(t,e,u,r);if(!a)return;const[s,l]=a,i=Number(s.number)%Number(l.number);("number"==typeof i||isNaN(i))&&(o(t).value=0===i?"0":`${i}${s.unit}`)}),!0),a.toString()}(v,f,c);e&&(v.value=e)}if(v.value.toLowerCase().includes(s)){const e=function(e,n,r){const a=t.default(e.value);return a.walk((a=>{if("function"!==a.type||"round"!==a.value.toLowerCase())return;if(3!==a.nodes.length&&5!==a.nodes.length)return void u(e,n,`Failed to transform ${e.value} as the amount of arguments isn't valid`,r);const s=a.nodes.filter((e=>"word"===e.type)),c=s[0].value;let f,d,v;if(i.test(c.toLowerCase())){var m,p;if(!Object.values(l).includes(c.toLowerCase()))return void u(e,n,`Failed to transform ${e.value} as ${c} is not a valid rounding strategy.`,r);f=c.toLowerCase(),d=t.default.unit((null==s||null==(m=s[1])?void 0:m.value)||""),v=t.default.unit((null==s||null==(p=s[2])?void 0:p.value)||"")}else{var b,w;f=l.Nearest,d=t.default.unit((null==s||null==(b=s[0])?void 0:b.value)||""),v=t.default.unit((null==s||null==(w=s[1])?void 0:w.value)||"")}if(!d||!v)return;if(d.unit!==v.unit)return void u(e,n,`Failed to transform ${e.value} as the units don't match`,r);const h=Number(d.number),N=Number(v.number);let $;switch(f){case l.Down:$=Math.floor(h/N)*N;break;case l.Up:$=Math.ceil(h/N)*N;break;case l.ToZero:$=Math.trunc(h/N)*N;break;case l.Nearest:default:$=Math.round(h/N)*N}"number"!=typeof $||isNaN($)||(o(a).value=0===$?"0":`${$}${d.unit}`)}),!0),a.toString()}(v,f,c);e&&(v.value=e)}e.value!==v.value&&(e.before(v),c.preserve||e.remove())}}};c.postcss=!0,module.exports=c;
