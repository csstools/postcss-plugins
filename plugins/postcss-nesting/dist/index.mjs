import e from"postcss-selector-parser";import{selectorSpecificity as t}from"@csstools/selector-specificity";function cleanupParent(e){if(!e.nodes.length)return void e.remove();const t=e.nodes.filter((e=>"comment"===e.type));t.length===e.nodes.length&&e.replaceWith(...t)}function shiftNodesBeforeParent(e,t){const n=t.index(e);if(n){const e=t.cloneBefore().removeAll().append(t.nodes.slice(0,n));e.raws.semicolon=!0,cleanupParent(e)}t.before(e),t.raws.semicolon=!0}function combinationsWithSizeN(e,t){if(t<2)throw new Error("n must be greater than 1");if(e.length<2)throw new Error("s must be greater than 1");if(Math.pow(e.length,t)>1e4)throw new Error("Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors");const n=[];for(let e=0;e<t;e++)n[e]=0;const o=[];for(;;){const r=[];for(let s=t-1;s>=0;s--){let t=n[s];if(t>=e.length){if(t=0,n[s]=0,0===s)return o;n[s-1]+=1}r[s]=e[t]}o.push(r),n[n.length-1]++}}const n=e.pseudo({value:":is"});function sortCompoundSelectorsInsideComplexSelector(t){if(!t||!t.nodes)return;const o=[];let r=[];for(let s=0;s<t.nodes.length;s++)if("combinator"!==t.nodes[s].type)if(e.isPseudoElement(t.nodes[s]))o.push(r),r=[t.nodes[s]];else{if("tag"===t.nodes[s].type&&r.find((e=>"tag"===e.type))){const o=n.clone({}),r=t.nodes[s];r.replaceWith(o),o.append(e.selector({nodes:[r],value:void 0}))}r.push(t.nodes[s])}else o.push(r),o.push([t.nodes[s]]),r=[];o.push(r);const s=[];for(let e=0;e<o.length;e++){const t=o[e];t.sort(((e,t)=>"selector"===e.type&&"selector"===t.type&&e.nodes.length&&t.nodes.length?selectorTypeOrder(e.nodes[0])-selectorTypeOrder(t.nodes[0]):"selector"===e.type&&e.nodes.length?selectorTypeOrder(e.nodes[0])-selectorTypeOrder(t):"selector"===t.type&&t.nodes.length?selectorTypeOrder(e)-selectorTypeOrder(t.nodes[0]):selectorTypeOrder(e)-selectorTypeOrder(t)));for(let e=0;e<t.length;e++)s.push(t[e])}for(let e=s.length-1;e>=0;e--)s[e].remove(),t.prepend(s[e])}function selectorTypeOrder(t){return e.isPseudoElement(t)?o.pseudoElement:o[t.type]}const o={universal:0,tag:1,pseudoElement:2,id:3,class:4,attribute:5,pseudo:6,selector:7,string:8,root:9,comment:10};function nodesAreEquallySpecific(n){const o=n.map((t=>e().astSync(t))).map((e=>t(e))),r=o[0];for(let e=1;e<o.length;e++)if(r.a!==o[e].a||r.b!==o[e].b||r.c!==o[e].c)return!1;return!0}function mergeSelectors(t,n,o,r,s,l=!1){let i=[];i=nodesAreEquallySpecific(o)||s.noIsPseudoSelector?o.map((t=>e().astSync(t))):[e().astSync(`:is(${o.join(",")})`)];const c=[];for(let o=0;o<r.length;o++){let f=r[o];{const s=e().astSync(f);var a,u,p,d;if(!l)0===o&&"tag"===(null==(a=s.nodes)||null==(u=a[0])||null==(p=u.nodes)||null==(d=p[0])?void 0:d.type)&&t.warn(n,`Nested selectors must start with a symbol : "${r[o]}"`);let i=!1;s.walk((e=>{"nesting"===e.type&&(i=!0)}));const c=s.nodes[0];let m=!1;c.each((e=>"combinator"===e.type&&(m=!0,!1))),i?m&&c.insertBefore(c.at(0),e.nesting({})):(c.insertBefore(c.at(0),e.combinator({value:" "})),c.insertBefore(c.at(0),e.nesting({}))),f=s.toString()}let m=1,h=[],g=0;if(e().astSync(f).walkNesting((()=>{g++})),g>1&&i.length>1)h=combinationsWithSizeN(i,g),m=h.length;else{m=i.length;for(let e=0;e<i.length;e++){h.push([]);for(let t=0;t<g;t++)h[e].push(i[e])}}for(let t=0;t<m;t++){let n=0;const o=e().astSync(f);o.walk((o=>{if("nesting"!==o.type)return;let r=h[t][n];n++,"root"===r.type&&1===r.nodes.length&&(r=r.nodes[0]);const l=e().astSync(`:is(${r.toString()})`),i=isSimpleSelector(r.nodes[0]),c=isCompoundSelector(r.nodes[0]),a=isSimpleSelector(o),u=isCompoundSelector(o);if(i&&a)return void o.replaceWith(r.clone());if((i||c)&&(a||u)){const e=o.parent;return i&&"selector"===r.type?o.replaceWith(r.clone().nodes[0]):o.replaceWith(...r.clone().nodes),void(e&&e.nodes.length>1&&sortCompoundSelectorsInsideComplexSelector(e))}if(i){const e=o.parent;return o.replaceWith(r.clone().nodes[0]),void(e&&sortCompoundSelectorsInsideComplexSelector(e))}if(c){const e=o.parent;return o.replaceWith(...r.clone().nodes),void(e&&sortCompoundSelectorsInsideComplexSelector(e))}if(nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(o)){const e=o.parent;return o.replaceWith(...r.clone().nodes),void(e&&sortCompoundSelectorsInsideComplexSelector(e))}if(nestingIsNotInsideCompoundSelector(o)){const e=o.parent;return o.replaceWith(...r.clone().nodes),void(e&&sortCompoundSelectorsInsideComplexSelector(e))}const p=o.parent;s.noIsPseudoSelector?o.replaceWith(...r.clone().nodes):o.replaceWith(...l.clone({}).nodes),p&&sortCompoundSelectorsInsideComplexSelector(p)})),c.push(o.toString())}}return c}function isSimpleSelector(e){return"combinator"!==e.type&&!(e.parent&&e.parent.nodes.length>1)}function isCompoundSelector(e,t=null){if(isSimpleSelector(e))return!1;if(!e.parent)return!1;if(!!e.parent.nodes.find((e=>"combinator"===e.type)))return!1;return!(!!e.parent.nodes.find((e=>"nesting"===e.type))&&t&&!isCompoundSelector(t))}function nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(e){if(!e.parent)return!1;if(0!==e.parent.nodes.indexOf(e))return!1;for(let t=1;t<e.parent.nodes.length;t++)if("combinator"===e.parent.nodes[t].type&&" "!==e.parent.nodes[t].value&&">"!==e.parent.nodes[t].value)return!1;return!0}function nestingIsNotInsideCompoundSelector(e){if(isSimpleSelector(e))return!0;if(!e.parent)return!1;for(let t=0;t<e.parent.nodes.length;t++)if("nesting"!==e.parent.nodes[t].type&&(e.parent.nodes[t].prev()||e.parent.nodes[t].next())){if(e.parent.nodes[t].prev()&&"combinator"!==e.parent.nodes[t].prev().type)return!1;if(e.parent.nodes[t].next()&&"combinator"!==e.parent.nodes[t].next().type)return!1}return!0}function groupDeclarations(e){let t=-1;e.each(((n,o)=>{if("decl"===n.type||"comment"===n.type&&n.next()&&"decl"===n.next().type){if(t===o-1)return void(t=o);n.remove(),e.insertAfter(t,n),t=e.index(n)}}))}function transformRuleWithinRule(e,t,n,o){let r=[];try{r=mergeSelectors(e,n,t.selectors,e.selectors,o,!1)}catch(o){return void e.warn(n,`Failed to parse selectors : "${t.selector}" / "${e.selector}" with message: "${o.message}"`)}groupDeclarations(t),shiftNodesBeforeParent(e,t),e.selectors=r;"rule"===e.type&&"rule"===t.type&&e.selector===t.selector&&e.append(...t.nodes),cleanupParent(t)}function isValidRuleWithinRule(e){return e.selectors.every((e=>-1===e.indexOf("|")))}function comma(e){const t=[];let n="",o=!1,r=0,s=!1,l=!1;for(const i of e)l?l=!1:"\\"===i?l=!0:s?i===s&&(s=!1):'"'===i||"'"===i?s=i:"("===i?r+=1:")"===i?r>0&&(r-=1):0===r&&","===i&&(o=!0),o?(""!==n&&t.push(n.trim()),n="",o=!1):n+=i;return t.push(n.trim()),t}function transformNestRuleWithinRule(e,t,n,o,r){shiftNodesBeforeParent(e,t);const s=t.clone().removeAll().append(e.nodes);s.raws.semicolon=!0;try{s.selectors=mergeSelectors(e,n,t.selectors,comma(e.params),r,!0)}catch(o){return void e.warn(n,`Failed to parse selectors : "${t.selector}" / "${e.params}" with message: "${o.message}"`)}e.replaceWith(s),cleanupParent(t),o(s,n,r)}function isValidNestRuleWithinRule(e){return comma(e.params).every((e=>e.split("&").length>=2&&-1===e.indexOf("|")))}var r=["container","document","media","supports","layer"];function atruleWithinRule(e,t,n,o,r){if(groupDeclarations(t),shiftNodesBeforeParent(e,t),e.nodes){const s=t.clone().removeAll().append(e.nodes);e.append(s),cleanupParent(t),o(s,n,r)}else cleanupParent(t)}function isAtruleWithinRule(e){return r.includes(e.name)}function transformAtruleWithinAtrule(e,t){var n,o;groupDeclarations(t),shiftNodesBeforeParent(e,t),e.params=(n=t.params,o=e.params,comma(n).map((e=>comma(o).map((t=>`${e} and ${t}`)).join(", "))).join(", ")),cleanupParent(t)}function isAtruleWithinAtrule(e,t){return r.includes(e.name)&&e.name===t.name}function isAtRule(e){return e&&"atrule"===e.type}function isNestRule(e){return e&&isAtRule(e)&&"nest"===e.name}function isRule(e){return e&&"rule"===e.type}function walk(e,t,n){e.each((e=>{const o=e.parent;isRule(e)&&isRule(o)&&isValidRuleWithinRule(e)?transformRuleWithinRule(e,o,t,n):isNestRule(e)&&isRule(o)&&isValidNestRuleWithinRule(e)?transformNestRuleWithinRule(e,o,t,walk,n):isAtRule(e)&&isRule(o)&&isAtruleWithinRule(e)?atruleWithinRule(e,o,t,walk,n):isAtRule(e)&&isAtRule(o)&&isAtruleWithinAtrule(e,o)&&transformAtruleWithinAtrule(e,o),"nodes"in e&&e.nodes.length&&walk(e,t,n)}))}const creator=e=>{const t=Object.assign({noIsPseudoSelector:!1},e);return{postcssPlugin:"postcss-nesting",Rule(e,{result:n}){walk(e,n,t)}}};creator.postcss=!0;export{creator as default};
