import{parseListOfComponentValues as e,isWhiteSpaceOrCommentNode as t,isTokenNode as s,isFunctionNode as o,stringify as n,isSimpleBlockNode as r,SimpleBlockNode as i}from"@csstools/css-parser-algorithms";import{tokenize as a,isTokenString as c,isTokenURL as p,isTokenIdent as u,isTokenOpenParen as m,TokenType as l}from"@csstools/css-tokenizer";import d from"node:path";import f from"node:module";import h from"node:fs/promises";import y from"@csstools/postcss-rebase-url";function isWarning(e){return"warning"===e.type}function isNodesStatement(e){return"nodes"===e.type}function isImportStatement(e){return"import"===e.type}function isPreImportStatement(e){return"pre-import"===e.type}const g=/^data:text\/css(?:;(?:base64|plain))?,/i,v=/^data:text\/css;base64,/i,I=/^data:text\/css;plain,/i;function isValidDataURL(e){return!!e&&g.test(e)}const S=/^charset$/i,N=/^import$/i,b=/^url$/i,$=/^layer$/i,w=/^supports$/i,C=/^scope$/i;function parseAtImport(r){const i=a({css:r});if(2===i.length&&(c(i[0])||p(i[0]))){let e=i[0][4].value;return e=stripHash(e),!!e&&{uri:e,fullUri:i[0][1]}}const m=e(i);let l,d,f,h,y="",g="";for(let e=0;e<m.length;e++){const r=m[e];if(!t(r))if(s(r)&&(c(r.value)||p(r.value))){if(y)return!1;y=r.value[4].value,g=r.value[1]}else if(o(r)&&b.test(r.getName())){if(y)return!1;for(let e=0;e<r.value.length;e++){const o=r.value[e];if(!t(o)){if(y||!s(o)||!c(o.value))return!1;y=o.value[4].value,g=n([[r]])}}}else{if(!y)return!1;if(s(r)&&u(r.value)&&$.test(r.value[4].value)){if(void 0!==l||void 0!==f)return!1;l=""}else if(o(r)&&$.test(r.getName())){if(void 0!==l||void 0!==f)return!1;if(!r.value.some(e=>!t(e)))return!1;l=n([r.value])}else if(o(r)&&w.test(r.getName())){if(void 0!==f)return!1;f=n([r.value])}else{if(!o(r)||!C.test(r.getName())){d=n([m.slice(e)]);break}if(void 0!==h)return!1;h=n([wrapInParenthesisIfNeeded(r.value)])}}}return y=stripHash(y),!!y&&{uri:y,fullUri:g,layer:l,media:d,supports:f,scope:h}}function wrapInParenthesisIfNeeded(e){for(let s=0;s<e.length;s++){const o=e[s];if(!t(o)&&(r(o)&&m(o.startToken)))return e}return[new i([l.OpenParen,"(",-1,-1,void 0],[l.CloseParen,")",-1,-1,void 0],e)]}function stripHash(e){if(e.startsWith("#"))return"";if(!e.includes("#"))return e;try{const t=new URL(e,"http://example.com");return t.hash?e.slice(0,e.length-t.hash.length):e}catch{return e}}function parseStylesheet(e,t,s,o,n){const r={statements:[]};if("document"===t.type)return t.each(t=>{const i=parseStylesheet(e,t,s,o,n);if(r.charset&&i.charset&&r.charset.params.toLowerCase()!==i.charset.params.toLowerCase())throw i.charset.error(`Incompatible @charset statements:\n  ${i.charset.params} specified in ${i.charset.source?.input.file}\n  ${r.charset.params} specified in ${r.charset.source?.input.file}`);!r.charset&&i.charset&&(r.charset=i.charset),r.statements.push(...i.statements)}),r;let i,a,c=[],p=[];for(let r=0;r<t.nodes.length;r++){const u=t.nodes[r];if(0===r&&"atrule"===u.type&&S.test(u.name))i=u;else if(p.length||"comment"!==u.type&&("atrule"!==u.type||!$.test(u.name)||u.nodes)){if(p.length||"atrule"!==u.type||!N.test(u.name)){a={type:"nodes",nodes:t.nodes.slice(r),conditions:[...o],from:n,importingNode:s};break}[r,p]=consumeImports(e,t.nodes,o,r,s,n)}else[r,c]=consumeBeforeImports(t.nodes,o,r,s,n)}const u=[];return c.length&&u.push(...c),p.length&&u.push(...p),a&&u.push(a),{charset:i,statements:u}}function consumeImports(e,t,s,o,n,r){const i=[];let a=o;const c=t.length;for(;a<c;a++){const o=t[a];if("comment"===o.type){const[e,s]=consumeComments(t,a,n,r);i.push(s),a=e;continue}if("atrule"!==o.type||!N.test(o.name))break;i.push(parseImport(e,o,n,s,r))}return[a-1,i]}function consumeBeforeImports(e,t,s,o,n){const r=[];let i=s;const a=e.length;for(;i<a;i++){const s=e[i];if("comment"===s.type){const[t,s]=consumeComments(e,i,o,n);r.push(s),i=t;continue}if("atrule"===s.type&&$.test(s.name)&&!s.nodes){if(t.length){r.push({type:"pre-import",node:s,conditions:[...t],from:n,importingNode:o});continue}{const[s,a]=consumeLayers(e,t,i,o,n);r.push(a),i=s;continue}}break}return[i-1,r]}function consumeComments(e,t,s,o){const n=[];let r=t;const i=e.length;for(;r<i;r++){const t=e[r];n.push(t);const s=e[r+1];if("comment"!==s?.type)break}return[r,{type:"nodes",nodes:n,conditions:[],from:o,importingNode:s}]}function consumeLayers(e,t,s,o,n){const r=[];let i=s;const a=e.length;for(;i<a;i++){const t=e[i];r.push(t);const s=e[i+1];if(!s||"atrule"!==s.type||!$.test(s.name)||s.nodes)break}return[i,{type:"nodes",nodes:r,conditions:[...t],from:n,importingNode:o}]}function parseImport(e,t,s,o,n){const r=parseAtImport(t.params);if(!r)return e.warn(`Invalid @import statement in '${t.toString()}'`,{node:t});const i={type:"import",uri:r.uri,fullUri:r.fullUri,node:t,conditions:[...o],from:n,importingNode:s};return void 0===r.layer&&void 0===r.media&&void 0===r.supports&&void 0===r.scope||i.conditions.push({layer:r.layer,media:r.media,supports:r.supports,scope:r.scope}),i}function resolveId(e,t,s,o){let n="";if(s.startsWith("node_modules:"))try{n=t.resolve(s.slice(13))}catch{throw e.error(`Failed to find '${s}'`)}else n=d.resolve(o,s);return n}function createRequire(e,t){let s;if(!e.source?.input?.file)return t.warn("The current PostCSS AST Node is lacking a source file reference. This is most likely a bug in a PostCSS plugin.",{node:e}),[];s=e.source.input.file;const o=d.dirname(s);return[f.createRequire(o),s,o]}async function loadContent(e){return isValidDataURL(e)?(t=e,v.test(t)?Buffer.from(t.slice(21),"base64").toString():I.test(t)?decodeURIComponent(t.slice(20)):decodeURIComponent(t.slice(14))):h.readFile(e,"utf-8");var t}const noopPlugin=()=>({postcssPlugin:"noop-plugin",Once(){}});async function parseStyles(e,t,s,o,n,r){const i=parseStylesheet(e,t,s,o,n);{let t,s,o;const n=[];for(const a of i.statements)isImportStatement(a)&&isProcessableURL(a.uri)&&(t&&s&&o||([t,s,o]=createRequire(a.node,e),t&&s&&o))&&n.push(resolveImportId(e,a,r,t,s,o));n.length&&await Promise.all(n)}for(let e=0;e<i.statements.length;e++){const t=i.statements[e];if(isImportStatement(t)&&t.stylesheet){if(i.charset&&t.stylesheet.charset&&i.charset.params.toLowerCase()!==t.stylesheet.charset.params.toLowerCase())throw t.stylesheet.charset.error(`Incompatible @charset statements:\n  ${t.stylesheet.charset.params} specified in ${t.stylesheet.charset.source?.input.file}\n  ${i.charset.params} specified in ${i.charset.source?.input.file}`);!i.charset&&t.stylesheet.charset&&(i.charset=t.stylesheet.charset),i.statements.splice(e,1,...t.stylesheet.statements),e--}else;}return i}async function resolveImportId(e,t,s,o,n,r){if(isValidDataURL(t.uri))return void(t.stylesheet=await loadImportContent(e,t,t.uri,s));if(isValidDataURL(t.from[t.from.length-1]))return t.stylesheet={statements:[]},void e.warn(`Unable to import '${t.uri}' from a stylesheet that is embedded in a data url`,{node:t.node});const i=resolveId(t.node,o,t.uri,r);e.messages.push({type:"dependency",plugin:"postcss-bundler",file:i,parent:n}),t.stylesheet=await loadImportContent(e,t,i,s)}async function loadImportContent(e,t,s,o){const{conditions:n,from:r,node:i}=t;if(r.includes(s))return{statements:[]};let a;try{a=await loadContent(s)}catch{throw i.error(`Failed to find '${t.uri}'`)}const c=await o([noopPlugin()]).process(a,{from:s,parser:e.opts.syntax?.parse??e.opts.parser??void 0}),p=c.root;return e.messages=e.messages.concat(c.messages),"atrule"===p.first?.type&&S.test(p.first.name)?p.first.after(o.comment({text:`${t.uri}`,source:i.source})):p.prepend(o.comment({text:`${t.uri}`,source:i.source})),parseStyles(e,p,i,n,[...r,s],o)}noopPlugin.postcss=!0;const P=/^(?:[a-z]+:)?\/\//i;function isProcessableURL(e){if(P.test(e))return!1;try{if(new URL(e,"https://example.com").search)return!1}catch{}return!0}function formatImportPrelude(e,t,s,o){const n=[];if(void 0!==e){let t="layer";e&&(t="layer("+e+")"),n.push(t)}return void 0!==s&&n.push("supports("+s+")"),void 0!==o&&n.push("scope("+o+")"),void 0!==t&&n.push(t),n.join(" ")}function base64EncodedConditionalImport(e,t){t.reverse();const s=t.pop();if(!s)return e;let o=`${e} ${formatImportPrelude(s.layer,s.media,s.supports,s.scope)}`;for(const e of t)o=`"data:text/css;base64,${Buffer.from(`@import ${o}`).toString("base64")}" ${formatImportPrelude(e.layer,e.media,e.supports,e.scope)}`;return o}function applyConditions(e,t){e.statements.forEach((s,o)=>{if(isWarning(s)||isPreImportStatement(s)||!s.conditions?.length)return;if(isImportStatement(s))return void(s.node.params=base64EncodedConditionalImport(s.fullUri,s.conditions));const n=s.nodes;if(!n.length)return;const r=n[0].parent;if(!r)return;const i=[];for(const e of s.conditions){if(void 0!==e.media){const o=t({name:"media",params:e.media,source:s.importingNode?.source??r.source});i.push(o)}if(void 0!==e.scope){const o=t({name:"scope",params:e.scope,source:s.importingNode?.source??r.source});i.push(o)}if(void 0!==e.supports){const o=t({name:"supports",params:"("+e.supports+")",source:s.importingNode?.source??r.source});i.push(o)}if(void 0!==e.layer){const o=t({name:"layer",params:e.layer,source:s.importingNode?.source??r.source});i.push(o)}}const a=i[0];if(!a)return;for(let e=0;e<i.length-1;e++)i[e].append(i[e+1]);const c=i[i.length-1];r.insertBefore(n[0],a),n.forEach(e=>{e.parent=void 0}),c.append(n),e.statements[o]={type:"nodes",nodes:[a],conditions:s.conditions,from:s.from,importingNode:s.importingNode}})}function applyStyles(e,t){t.nodes=[],e.charset&&(e.charset.parent=void 0,t.append(e.charset)),e.statements.forEach(e=>{isImportStatement(e)?(e.node.parent=void 0,t.append(e.node)):isNodesStatement(e)&&e.nodes.forEach(e=>{e.parent=void 0,t.append(e)})})}function postProcess(e,t,s){let o=-1,n=-1;for(let t=0;t<e.statements.length;t++){isImportStatement(e.statements[t])&&(-1===o&&(o=t),n=t)}for(let r=0;r<e.statements.length;r++){const i=e.statements[r];if(!isImportStatement(i)&&(!isWarning(i)&&(!isNodesStatement(i)||i.importingNode)))if(isPreImportStatement(i))if(r<n){const s="data:text/css;base64,"+Buffer.from(i.node.toString()).toString("base64"),o={type:"import",uri:s,fullUri:'"'+s+'"',node:t({name:"import",params:'"'+s+'"',source:i.node.source}),conditions:i.conditions,from:i.from,importingNode:i.importingNode};e.statements.splice(r,1,o)}else{const t={type:"nodes",nodes:[i.node],conditions:i.conditions,from:i.from,importingNode:i.importingNode};e.statements.splice(r,1,t)}else if(!(r<o&&i.nodes.every(e=>"atrule"===e.type&&!e.nodes))&&!(r<n&&i.nodes.every(e=>"comment"===e.type))&&r<n){const o=s();i.nodes.forEach(e=>{e.parent=void 0,o.append(e)});const n="data:text/css;base64,"+Buffer.from(o.toString()).toString("base64"),a={type:"import",uri:n,fullUri:'"'+n+'"',node:t({name:"import",params:'"'+n+'"',source:i.importingNode?.source??i.nodes[0]?.source}),conditions:i.conditions,from:i.from,importingNode:i.importingNode};e.statements.splice(r,1,a)}}}const creator$1=()=>({postcssPlugin:"postcss-bundler",async Once(e,{result:t,atRule:s,root:o,postcss:n}){const r=await parseStyles(t,e,null,[],[],n);postProcess(r,s,o),applyConditions(r,s),applyStyles(r,e)}});creator$1.postcss=!0;const creator=()=>({postcssPlugin:"postcss-bundler",plugins:[creator$1(),y()]});creator.postcss=!0;export{creator as default};
